############################################################################
# Project: Electrical Pre-Conditioning of Convective Clouds,
# Title: Plotting Radiosonde Data
# Author: James Gilmore,
# Email: james.gilmore@pgr.reading.ac.uk.
# Version: 1.10
# Date: 15/01/2019
# Status: Stable
# Change: Added in PointCharge and ChargeOpticalCorrelation
############################################################################
from __future__ import absolute_import, division, print_function
import matplotlib.pyplot as plt
from matplotlib.dates import DateFormatter
import numpy as np
import scipy as sp
import pandas as pd
import os, sys, time, warnings, glob, argparse
from datetime import datetime, timedelta

sys.path.insert(0, '/home/users/th863480/PhD/Global_Functions')

#User Processing Modules
import Gilly_Utilities as gu

#Data Set-up Modules
from Data_Importer import EPCC_Importer
from Data_Quality import Radiosonde_Checks_v2 as  Radiosonde_Checks
from Data_Output import SPRadiosonde, CrossCorrelation_Scatter_Plot

#Import Global Variables
import PhD_Config as PhD_Global

#Import Tephigram Plotter
from Extras.Tephigram import Tephigram as SPTephigram

#Import WC3 Extras (for GPS2UTC)
from Extras.WC3_Extras import GPS2UTC, CloudDrift, Radiosonde_Launch

class Radiosonde(EPCC_Importer, Radiosonde_Checks, SPRadiosonde, SPTephigram):
	"""This class will process all the data aquired from a radiosonde output the data in various forms,
	including, height plot, tepihgram and indicies.
	
	Parameters
	----------
	EPCC_Importer : class
		Used to import other datasets other than the actual radiosonde
	Radiosonde_Checks : class
		Used to quality control the radiosonde data
	SPRadiosonde : class
		Used to plot the radiosonde data
`	SPTephigram : class
		Used to plot the tepihgram of the data
		
	"""
	
	def __init__(self, sensor_package, height_range, calibrate='Counts', reload=False, verbose=False):
		"""Set-up radiosonde data.
		
		Parameters
		----------
		sensor_package : int
			The sensor package number flown for the PhD.
		height_range : array_like
			The height range used to limit the data. Must be array_like with two elements
			specifying the lower and upper bands in kilometres. 
			
			e.g. height_range = (<lower_bound_in_km>, <upper_bound_in_km>),
		calibrate : str, optional
			The type of data to plot. Either 'Counts', 'Volts' or 'Units' are acceptable.
		reload : bool, optional
			Specify whether to re-process the radiosonde data. N.B. if data has not
			already proccessed at the particular height_range specified, the data will
			be reprocessed.
		verbose : bool, optional
			Specify whether to output extra information about the processing to the 
			console.
		"""
		
		############################################################################
		"""Prerequisites"""
    
		#Time Controls
		t_begin = time.time()
		
		#Error Checks
		if sensor_package is None: sys.exit("[Error] You must specify either the sensor_package number")
		if height_range is None: sys.exit("[Error] You must specify either the height_range number")
		
		#Storage Locations
		self.Storage_Path    		= PhD_Global.Storage_Path_WC3
		self.Processed_Data_Path	= 'Processed_Data/Radiosonde/'
		self.Raw_Data_Path			= 'Raw_Data/'
		self.Radiosonde_Plots_Path  = 'Plots/Radiosonde/'
		self.Tephigram_Plots_Path   = 'Plots/Tephigram/'
		
		#Bound classes
		self.importer = EPCC_Importer()
		self.sensor_package = sensor_package
		self.height_range = height_range
		self.calibrate = calibrate
		self.reload = reload
		self.verbose = verbose
		self.data = PhD_Global.Data
		
		#Real name for all Pandora Channels for each radiosonde launch
		self.RawChannelList = {0 : ['Lin', 'Log', 'Cyan/PLL', 'IR', 'Parity'],
			1 : ['Lin', 'Log', 'Cyan/PLL', 'IR', 'Parity'],
			2 : ['Lin', 'Log', 'Cyan/PLL', 'IR', 'Parity'],
			3 : ['Lin', 'Log', 'Cyan/PLL', 'IR', 'Parity'],
			4 : ['Lin', 'Log', 'Cyan/PLL', 'IR', 'Parity'],
			5 : ['Lin', 'Log', 'Cyan/PLL', 'IR', 'Parity'],
			6 : ['Lin', 'Log/Turbulence', 'Cyan', 'IR/Parity'], #Not Launched Yet
			7 : ['Lin', 'Log/Turbulence', 'Cyan', 'IR/Parity'], #Not Launched Yet
			8 : ['Lin', 'Log/Turbulence', 'Cyan', 'IR/Parity'], #Not Launched Yet
			9 : ['Lin', 'Log', 'Cyan', 'IR', 'Turbulence'],
			10 : ['Lin', 'Log', 'Cyan', 'IR', 'Turbulence']}
		
		#Number of bits (2^n)
		self.NumofBits = {0 : 12,
			1 : 12,
			2 : 12,
			3 : 12,
			4 : 12,
			5 : 12,
			6 : 16, #Not Launched Yet
			7 : 16, #Not Launched Yet
			8 : 16, #Not Launched Yet
			9 : 12,
			10 : 12}
		
		#Launch Time (UTC)
		self.LaunchTime = {0 : "N/A",
			1 : "N/A",
			2 : "N/A",
			3 : "N/A",
			4 : "N/A",
			5 : np.datetime64("2018-07-27 15:39"),
			6 : None, #Not Launched Yet
			7 : None, #Not Launched Yet
			8 : None, #Not Launched Yet
			9 : "N/A",
			10 : "N/A"}
		
		############################################################################
		
		#Import Radiosonde Data
		self.Radiosonde_Data, self.Launch_Datetime = self._RadiosondeImporter(self.sensor_package)
	
		#Identify clouds within data
		self.Clouds_ID, self.LayerType = self._CloudIdentifier()
		
		#Calculate the space charge density using the log charge sensor
		#self.Calibration_Log = self._ChargeCalibrator(self.calibrate, self.sensor_package, self.Clouds_ID, self.LayerType) if np.any(np.in1d(self.calibrate, ['Volts', 'Units'])) else None
		
	def _RadiosondeImporter(self, Sensor_Package=None):
		"""Check and Import Data"""
		
		#Error check that either Radiosonde_File or Sensor_Package has been specified
		if Sensor_Package is None: sys.exit("[Error] You must specify either the Sensor_Package number")
		
		t1 = time.time()
		
		#First check if any NumPy processed files are available for this sensor package
		file_check = glob.glob(self.Storage_Path + self.Processed_Data_Path + 'Radiosonde_Flight_No.' + str(Sensor_Package).rjust(2,'0') + '_*/Radiosonde_Flight_PhD_James_No.' + str(Sensor_Package) + '*.npy')
		
		tester = ['No.' + str(Sensor_Package), str(self.height_range[0]) + 'km', str(self.height_range[1]) + 'km']
		if np.any(gu.string_checker(file_check, tester, condition='all')) and self.reload is False:
			
			print("[INFO] Getting radiosonde data from file")
			
			#Find correct file to import
			self.Radiosonde_File = file_check[gu.bool2int(gu.string_checker(file_check, tester, condition='all'))[0]]
			
			#Load data using careful method (see: https://stackoverflow.com/a/45661259/8765762)
			Radiosonde_Data = np.load(self.Radiosonde_File).item()
			
			#Load GPS data
			tester = ['No.' + str(Sensor_Package), 'GPSdata']
			self.GPS_File = file_check[gu.bool2int(gu.string_checker(file_check, tester, condition='all'))[0]]
			GPS_Data = np.load(self.GPS_File)
			
			#Estimate the launch time from the data
			GPS_Data = GPS_Data[~np.isnan(GPS_Data['SondeX'])]
			Launch_Datetime = GPS2UTC(GPS_Data['GPS_Week'][0], GPS_Data['GPS_Second'][0])
				
		else:
			
			print("[INFO] Processing radiosonde data from scratch")
			
			#Attempt to find the radiosonde file either directly or from glob
			self.Radiosonde_File = glob.glob(self.Storage_Path + self.Processed_Data_Path + 'Radiosonde_Flight_No.' + str(Sensor_Package).rjust(2,'0') + '_*/Radiosonde_Flight_PhD_James_No.' + str(Sensor_Package) + '*a.txt')
			
			#If no radiosonde file was found we end program
			if len(self.Radiosonde_File) == 0: sys.exit("[Error] Radiosonde package No.%s does not exist. Has the radiosonde been launched yet or has the data been misplaced?" % (Sensor_Package))
			
			#If the radiosonde file was found via glob we need to convert to str from list
			if isinstance(self.Radiosonde_File, list): self.Radiosonde_File = self.Radiosonde_File[0]
			
			#Once the radiosonde file is found we can attempt to find the GPS file in the raw file section
			self.GPS_File = glob.glob(self.Storage_Path + self.Raw_Data_Path + 'Radiosonde_Flight_No.' + str(Sensor_Package).rjust(2,'0') + '_*/GPSDCC_RESULT*.tsv')
			
			#Import all the data		
			Radiosonde_Data =  pd.read_csv(self.Radiosonde_File, sep=r"\s*", header=None, engine='python',
				names=('time', 
				'height', 
				'P', 
				'Tdry', 
				'RH',
				self.RawChannelList[Sensor_Package][0],
				self.RawChannelList[Sensor_Package][1],
				self.RawChannelList[Sensor_Package][2],
				self.RawChannelList[Sensor_Package][3],
				self.RawChannelList[Sensor_Package][4],
				'long',
				'lat',
				'range',
				'bearing',
				'Tdew',
				'u',
				'v',
				'MR'), 
				dtype={'time': np.float64, 
				'height': np.float64, 
				'P': np.float64, 
				'Tdry': np.float64, 
				'RH': np.float64, 
				self.RawChannelList[Sensor_Package][0]: np.float64, 
				self.RawChannelList[Sensor_Package][1]: np.float64, 
				self.RawChannelList[Sensor_Package][2]: np.float64, 
				self.RawChannelList[Sensor_Package][3]: np.float64, 
				self.RawChannelList[Sensor_Package][4]: np.float64, 
				'long': np.float64, 
				'lat': np.float64, 
				'range': np.float64, 
				'bearing': np.float64, 
				'Tdew': np.float64, 
				'u': np.float64, 
				'v': np.float64, 
				'MR': np.float64},
				na_values=-32768, comment='#', index_col=False).to_records(index=False)
					
			GPS_Data =  pd.read_csv(self.GPS_File[0], sep="\t", skiprows=51, header=None, usecols=(1,2,4),
				names=('GPS_Week', 
				'GPS_Second', 
				'SondeX'), 
				dtype={'GPS_Week': np.int32, 
				'GPS_Second': np.float64, 
				'SondeX': np.float64},
				na_values=-32768, comment='#', index_col=False).to_records(index=False) if len(self.GPS_File) != 0 else None
			
			#Fix np.recarray issue
			Radiosonde_Data = gu.fix_recarray(Radiosonde_Data)
			GPS_Data = gu.fix_recarray(GPS_Data)
			
			#Estimate the launch time from the data
			if self.GPS_File is not None: 
				GPS_Data = GPS_Data[~np.isnan(GPS_Data['SondeX'])]
				Launch_Datetime = GPS2UTC(GPS_Data['GPS_Week'][0], GPS_Data['GPS_Second'][0])
					
			#Calibrate Height, Temperature and Convert PANDORA channels from counts to volts if required.
			Radiosonde_Cal_Counts = Radiosonde_Checks(Radiosonde_Data.copy(), None, self.sensor_package, self.height_range, check=1111, verbose=self.verbose)
			Radiosonde_Cal_Volts = Radiosonde_Checks(Radiosonde_Data.copy(), 'Volts', self.sensor_package, self.height_range, check=1111, verbose=self.verbose)
			Radiosonde_Cal_Units = Radiosonde_Checks(Radiosonde_Data.copy(), 'Units', self.sensor_package, self.height_range, check=1111, verbose=self.verbose)
				
			#Calibrate RH
			Radiosonde_Cal_Counts.RH()
			Radiosonde_Cal_Volts.RH()
			Radiosonde_Cal_Units.RH()
			
			#Calibrate Cloud Sensor
			Radiosonde_Cal_Counts.Cloud(method='offset')
			Radiosonde_Cal_Volts.Cloud(method='offset')
			Radiosonde_Cal_Units.Cloud(method='offset')
			
			#Calibrate Charge
			Radiosonde_Cal_Volts.Charge()
			Radiosonde_Cal_Units.Charge(lab_calibration=True)
			
			#Calibrate Vibrating Wire
			Radiosonde_Cal_Volts.PLL()
			Radiosonde_Cal_Units.PLL()
			
			#Nest Radiosonde_Cal into Radiosonde_Data
			Radiosonde_Data = {'Date' : Launch_Datetime,
				'Raw' : Radiosonde_Data,
				'Counts' : Radiosonde_Cal_Counts.finalise(),
				'Volts' : Radiosonde_Cal_Volts.finalise(),
				'Units' : Radiosonde_Cal_Units.finalise()}		
			
			#Save Radiosonde_Data to file. N.B. numpy is not perfect for saving dictionaries. Becareful when loading data again!
			Save_Loc = self.Storage_Path + self.Processed_Data_Path + 'Radiosonde_Flight_No.' + \
				str(Sensor_Package).rjust(2,'0') + '_' + Launch_Datetime.strftime('%Y%m%d') + \
				'/Radiosonde_Flight_PhD_James_No.' + str(Sensor_Package) + '_' + Launch_Datetime.strftime('%Y%m%d') + \
				'_' + str(self.height_range[0]) + 'km_to_' + str(self.height_range[1]) + 'km_Ascent.npy'
			np.save(Save_Loc, Radiosonde_Data)
			
			#Save GPS data
			Save_Loc = self.Storage_Path + self.Processed_Data_Path + 'Radiosonde_Flight_No.' + \
				str(Sensor_Package).rjust(2,'0') + '_' + Launch_Datetime.strftime('%Y%m%d') + \
				'/Radiosonde_Flight_PhD_James_No.' + str(Sensor_Package) + '_' + Launch_Datetime.strftime('%Y%m%d') + \
				'_' + 'GPSdata.npy'
			np.save(Save_Loc, GPS_Data)
		
		return Radiosonde_Data, Launch_Datetime
	
	def _CloudIdentifier(self):
		"""This function will identify the cloud layers within a radiosonde ascent by using the cloud sensor and 
		relative humidity measurements
		
		Reference
		---------
		Zhang, J., H. Chen, Z. Li, X. Fan, L. Peng, Y. Yu, and M. Cribb (2010). Analysis of cloud layer structure 
			in Shouxian, China using RS92 radiosonde aided by 95 GHz cloud radar. J. Geophys. Res., 115, D00K30, 
			doi: 10.1029/2010JD014030.
		WMO, 2017. Clouds. In: Internal Cloud Atlas Manual on the Observation of Clouds and Other Meteors. 
			Hong Kong: WMO, Section 2.2.1.2.
		"""
		
		if self.verbose is True: gu.cprint("[INFO] You are running Radiosonde_CloudIdentifier from the STABLE release", type='bold')
		
		############################################################################
		"""[METHOD 1]: Relative Humidity (Zhang et al. 2010)"""
		
		#Define data into new variables
		Z = self.Radiosonde_Data['Counts']['height'].copy()
		RH = self.Radiosonde_Data['Counts']['RHice'].copy()
		
		#Create Height-Resolving RH Thresholds (see Table 1 in Zhang et al. (2010))
		#N.B. use np.interp(val, RH_Thresholds['altitude'], RH_Thresholds['*RH']) where val is the height range you want the RH Threshold 
		RH_Thresholds = {'minRH' : [0.92, 0.90, 0.88, 0.75, 0.75],
			'maxRH' : [0.95, 0.93, 0.90, 0.80, 0.80],
			'interRH' : [0.84, 0.82, 0.78, 0.70, 0.70],
			'altitude' : [0, 2, 6, 12, 20]}
		
		#Define the cloud height levels as defined by WMO (2017). 
		Z_Levels = {'low' : [0,2], 'middle' : [2,7], 'high' : [5,13]}
		
		#Define the types of layers that can be detected.
		Cloud_Types = {0 : 'Clear Air', 1 : 'Moist (Not Cloud)', 2 : 'Cloud'}
		
		#Define the min, max and interRH for all measure altitudes
		minRH = np.interp(Z, RH_Thresholds['altitude'], RH_Thresholds['minRH'], left=np.nan, right=np.nan)*100
		maxRH = np.interp(Z, RH_Thresholds['altitude'], RH_Thresholds['maxRH'], left=np.nan, right=np.nan)*100
		interRH = np.interp(Z, RH_Thresholds['altitude'], RH_Thresholds['interRH'], left=np.nan, right=np.nan)*100
		
		#[Step 1]: The base of the lowest moist layer is determined as the level when RH exceeds the min-RH corresponding to this level
		minRH_mask = (RH > minRH)
		
		#[Step 2 and 3]: Above the base of the moist layer, contiguous levels with RH over the corresponding min-RH are treated as the same layer
		Z[~minRH_mask] = np.nan
		Clouds_ID = gu.contiguous(Z, 1)
		
		#[Step 4]: Moist layers with bases lower than 120m and thickness's less than 400m are discarded
		for Cloud in np.unique(Clouds_ID)[1:]:
			if Z[Clouds_ID == Cloud][0] < 0.12:
				if Z[Clouds_ID == Cloud][-1] - Z[Clouds_ID == Cloud][0] < 0.4:
					Clouds_ID[Clouds_ID == Cloud] = 0
		
		#[Step 5]: The moist layer is classified as a cloud layer is the maximum RH within this layer is greater than the corresponding max-RH at the base of this moist layer
		LayerType = np.zeros(Z.size, dtype=int) #0: Clear Air, 1: Moist Layer, 2: Cloud Layer
		for Cloud in np.unique(Clouds_ID)[1:]:
			if np.any(RH[Clouds_ID == Cloud] > maxRH[Clouds_ID == Cloud][0]):
				LayerType[Clouds_ID == Cloud] = 2
			else:
				LayerType[Clouds_ID == Cloud] = 1
		
		#[Step 6]: The base of the cloud layers is set to 280m AGL, and cloud layers are discarded if their tops are lower than 280m	
		for Cloud in np.unique(Clouds_ID)[1:]:
			if Z[Clouds_ID == Cloud][-1] < 0.280:
				Clouds_ID[Clouds_ID == Cloud] = 0
				LayerType[Clouds_ID == Cloud] = 0

		#[Step 7]: Two contiguous layers are considered as one-layer cloud if the distance between these two layers is less than 300m or the minimum RH within this distance is more than the maximum inter-RG value within this distance
		for Cloud_Below, Cloud_Above in zip(np.unique(Clouds_ID)[1:-1], np.unique(Clouds_ID)[2:]):
			
			#Define the index between clouds of interest
			Air_Between = np.arange(gu.bool2int(Clouds_ID == Cloud_Below)[-1], gu.bool2int(Clouds_ID == Cloud_Above)[0])
			
			if ((Z[Clouds_ID == Cloud_Above][0] - Z[Clouds_ID == Cloud_Below][-1]) < 0.3) or (np.nanmin(RH[Air_Between]) > np.nanmax(interRH[Air_Between])):
				Joined_Cloud_Mask = np.arange(gu.bool2int(Clouds_ID == Cloud_Below)[0], gu.bool2int(Clouds_ID == Cloud_Above)[-1])
				
				#Update the cloud ID array as the Cloud_Below and Cloud_Above are not distinct clouds
				Clouds_ID[Joined_Cloud_Mask] = Cloud_Below
				
				#Update the LayerType to reflect the new cloud merging
				if np.any(LayerType[Clouds_ID == Cloud_Below] == 2) or np.any(LayerType[Clouds_ID == Cloud_Above] == 2):
					LayerType[Joined_Cloud_Mask] = 2
				else:
					LayerType[Joined_Cloud_Mask] = 1
			
		#[Step 8] Clouds are discarded if their thickness's are less than 30.5m for low clouds and 61m for middle/high clouds
		for Cloud in np.unique(Clouds_ID)[1:]:
			if Z[Clouds_ID == Cloud][0] < Z_Levels['low'][1]:
				if Z[Clouds_ID == Cloud][-1] - Z[Clouds_ID == Cloud][0] < 0.0305:
					Clouds_ID[Clouds_ID == Cloud] = 0
					LayerType[Clouds_ID == Cloud] = 0

			else:
				if Z[Clouds_ID == Cloud][-1] - Z[Clouds_ID == Cloud][0] < 0.0610:
					Clouds_ID[Clouds_ID == Cloud] = 0
					LayerType[Clouds_ID == Cloud] = 0
		
		#Re-update numbering of each cloud identified
		Clouds_ID = gu.contiguous(Clouds_ID, invalid=0)
		
		#Output verbose to screen
		if self.verbose is True:
			print("Detected Clouds and Moist Layers\n--------------------------------")
			for Cloud in np.unique(Clouds_ID)[1:]:
				print("Cloud %s. Cloud Base = %.2fkm, Cloud Top = %.2fkm, Layer Type: %s" % (Cloud, Z[Clouds_ID == Cloud][0], Z[Clouds_ID == Cloud][-1], Cloud_Types[LayerType[Clouds_ID == Cloud][0]]))
			
		return Clouds_ID, LayerType
	
	def _ChargeCalibrator(self, Calibrate=None, Sensor_Package=None, Clouds_ID=None, LayerType=None):

		if self.verbose is True: gu.cprint("[INFO] You are running Radiosonde_ChargeCalibrator from the DEV release", type='bold')

		############################################################################
		"""Prerequisites"""
		
		#Time Controls
		t_begin = time.time()
			
		#Plotting requirements
		import matplotlib.pyplot as plt
		plt.style.use('classic') #necessary if Matplotlib version is >= 2.0.0
		
		#Calibration boundaries
		Height_Boundaries = {0 : [],
			1 : [],
			2 : [],
			3 : [],
			4 : [10.0,12.0],
			5 : [10.5,12.0],
			6 : [],
			7 : [],
			8 : [],
			9 : [6,12.0],
			10 : [12,18.0]}
			
		############################################################################
		"""[Step 1] Calibrate bespoke sensors"""
		
		Radiosonde_Data = self.Radiosonde_Data['Units'].copy()
					
		Linear = gu.moving_average(Radiosonde_Data['Lin_Current'], 11)
		Log = gu.moving_average(Radiosonde_Data['Log_Current'], 11)
		
		PosMask = Linear >= 0
		NegMask = Linear < 0
		
		LinearPos = np.log10(Linear[PosMask])
		LogPos = Log[PosMask]
		
		LinearNeg = -np.log10(-Linear[NegMask])
		LogNeg = Log[NegMask]
			
		#Calculate Linear Regressions
		slope_all, intercept_all, r_value_all, p_value_all, std_err_all = sp.stats.linregress(Log, Linear)
		slope_pos, intercept_pos, r_value_pos, p_value_pos, std_err_pos = sp.stats.linregress(LogPos, LinearPos)
		try:
			slope_neg, intercept_neg, r_value_neg, p_value_neg, std_err_neg = sp.stats.linregress(LogNeg, LinearNeg)
		except:
			slope_neg, intercept_neg, r_value_neg, p_value_neg, std_err_neg = (0,0,0,0,0)
		
		if self.verbose is True: print(slope_all, intercept_all, r_value_all, p_value_all, std_err_all)
		if self.verbose is True: print(slope_pos, intercept_pos, r_value_pos, p_value_pos, std_err_pos)
		if self.verbose is True: print(slope_neg, intercept_neg, r_value_neg, p_value_neg, std_err_neg)
		
		############################################################################
		"""[Step 2] Plot the calibration values for positive and negative linear currents"""
		
		plt.clf()
		plt.close()
		
		f, ax = plt.subplots(1,3)
		ax[0].plot(Log, Linear , 'p', ms=1, marker='o', markeredgecolor='None', markerfacecolor='black', alpha=1, label="Clouds")
		ax[1].plot(LogPos, LinearPos , 'p', ms=1, marker='o', markeredgecolor='None', markerfacecolor='black', alpha=1, label="Clouds")
		ax[2].plot(LogNeg, LinearNeg , 'p', ms=1, marker='o', markeredgecolor='None', markerfacecolor='black', alpha=1, label="Clouds")
		
		ax[0].plot(Log, slope_all*Log+intercept_all, lw=0.5, c='red')
		ax[1].plot(LogPos, slope_pos*LogPos+intercept_pos, lw=0.5, c='red')
		ax[2].plot(LogNeg, slope_neg*LogNeg+intercept_neg, lw=0.5, c='red')
		
		ax[0].set_ylabel("Linear Sensor Current (A)", fontsize=8)
		ax[1].set_ylabel("Linear Sensor Current (log10(pA))", fontsize=8)
		ax[2].set_ylabel("Linear Sensor Current (-log10(-pA))", fontsize=8)

		for subplot in ax: subplot.minorticks_on()
		for subplot in ax: subplot.set_xlabel("Log Sensor Current (Counts)", fontsize=8)
		for subplot in ax: subplot.grid(which='major',axis='both',c='grey')
		for subplot in ax: subplot.tick_params(axis='both', which='major', labelsize=8)
		for subplot in ax: subplot.tick_params(axis='both', which='minor', labelsize=8)
		
		f.suptitle("Linear and Log Charge Sensors for Radiosonde Flight No.5", y=0.90)
		
		ax[0].get_xaxis().get_major_formatter().labelOnlyBase = False
		
		for subplot in ax:
			x0, x1 = subplot.get_xlim()
			y0, y1 = subplot.get_ylim()
			subplot.set_aspect(np.abs((x1-x0)/(y1-y0)))
		
		ax[0].annotate("All Data", xy=(0, 1), xycoords='axes fraction', xytext=(20, -20), textcoords='offset pixels', horizontalalignment='left', verticalalignment='top', fontsize=8)
		ax[1].annotate("Positive Linear Current", xy=(0, 1), xycoords='axes fraction', xytext=(20, -20), textcoords='offset pixels', horizontalalignment='left', verticalalignment='top', fontsize=8)
		ax[2].annotate("Negative Linear Current", xy=(0, 1), xycoords='axes fraction', xytext=(20, -20), textcoords='offset pixels', horizontalalignment='left', verticalalignment='top', fontsize=8)
		
		ax[0].annotate("$R^{2}$ = %.4f\n$Counts$ = %.0f" % (r_value_all**2, Log.size), xy=(1, 1), xycoords='axes fraction', fontsize=8, xytext=(-3, -3), textcoords='offset points', ha='right', va='top')
		ax[1].annotate("$R^{2}$ = %.4f\n$Counts$ = %.0f" % (r_value_pos**2, LogPos.size), xy=(1, 1), xycoords='axes fraction', fontsize=8, xytext=(-3, -3), textcoords='offset points', ha='right', va='top')
		ax[2].annotate("$R^{2}$ = %.4f\n$Counts$ = %.0f" % (r_value_neg**2, LogNeg.size), xy=(1, 1), xycoords='axes fraction', fontsize=8, xytext=(-3, -3), textcoords='offset points', ha='right', va='top')
					
		f.set_size_inches(11.7, 4.3)
		
		############################################################################
		"""[Step 3] Save plot to file"""
		
		#Specify the directory the plots are stored in 
		path = os.path.dirname(self.Radiosonde_File).replace(self.Storage_Path + self.Processed_Data_Path,"")

		#Find any other plots stored in this directory
		previous_plots = glob.glob(self.Storage_Path + self.Radiosonde_Plots_Path + path + "/*")
		
		#Find the biggest 'v' number in plots
		plot_version = []
		for plots in previous_plots:
			try:
				plot_version.append(int(os.path.basename(plots)[34:37]))
			except ValueError:
				plot_version.append(int(os.path.basename(plots)[34:36]))
		
		plot_version = str(np.max(plot_version)+1) if len(plot_version) != 0 else '1'
		
		#Create full directory and file name
		Save_Location = self.Storage_Path + self.Radiosonde_Plots_Path + path + '/' + path + '_v' + plot_version.rjust(2,'0') + '_ChargeCalibrator.png'

		#Ensure the directory exists on file system and save to that location
		gu.ensure_dir(os.path.dirname(Save_Location))
		plt.savefig(Save_Location, bbox_inches='tight', pad_inches=0.1, dpi=300)
		
		#Return regression of positive current, regression of negative current and the boundary for counts
		return (slope_all, intercept_all), (slope_pos, intercept_pos), (slope_neg, intercept_neg), (PosMask, NegMask)
		
	def Superplotter(self):
		"""This function will plot the data from a single radiosonde flight
		"""
		
		if self.verbose is True: gu.cprint("[INFO] You are running Superplotter from the DEV release", type='bold')
		
		############################################################################
		"""Prerequisites"""
		
		t_begin = time.time()

		############################################################################
		"""[Step 1] Plot radiosonde data"""

		Title = 'Radiosonde Flight No.' + str(self.sensor_package) + ' (' + self.Launch_Datetime.strftime("%d/%m/%Y %H%MUTC") + ')' if self.GPS_File is not None else 'Radiosonde Flight (N/A)'
		if self.sensor_package < 8:
			Superplotter = SPRadiosonde(8, Title, self.height_range, self.Radiosonde_Data[self.calibrate], calibrate=self.calibrate) if self.calibrate == "Units" else SPRadiosonde(7, Title, self.height_range, self.Radiosonde_Data[self.calibrate], calibrate=self.calibrate)
		else:	
			Superplotter = SPRadiosonde(7, Title, self.height_range, self.Radiosonde_Data[self.calibrate], calibrate=self.calibrate)
		
		if self.calibrate in ['Counts', 'Volts']:
			Superplotter.Charge(type='counts')
		else:
			Superplotter.Charge(type='space_charge')
		
		if self.sensor_package < 8:
			Superplotter.Cloud(mask_cyan=(self.Radiosonde_Data[self.calibrate]['Parity'] == 1111))
			Superplotter.PLL(type='freq', mask_pll=(self.Radiosonde_Data[self.calibrate]['Parity'] == 1112), point=False) if self.sensor_package < 3 else Superplotter.PLL(type='freq', mask_pll=(self.Radiosonde_Data[self.calibrate]['Parity'] == 1112), point=True)
			if self.calibrate in ['Units']: Superplotter.PLL(type='slwc', mask_pll=(self.Radiosonde_Data[self.calibrate]['Parity'] == 1112), point=False) if self.sensor_package < 3 else Superplotter.PLL(type='slwc', mask_pll=(self.Radiosonde_Data[self.calibrate]['Parity'] == 1112), point=True)
		else:
			Superplotter.Cloud()
			Superplotter.Turbulence()
			
		#Plot the processed PLL data
		if (self.calibrate == "units") & (self.sensor_package < 8): Superplotter.ch(14, 'SLWC $(g$ $m^{-3})$', 'Supercooled Liquid\nWater Concentration', check=1112, point=True)
		
		#Plot the cloud boundaries if specified
		if self.Clouds_ID is not None: Superplotter.Cloud_Boundaries(self.Clouds_ID, self.LayerType, CloudOnly=True)
		
		############################################################################
		"""[Step 2] Save plot and return"""
		
		#Specify the directory the plots are stored in 
		path = os.path.dirname(self.Radiosonde_File).replace(self.Storage_Path + self.Processed_Data_Path,"")
		
		#Find any other plots stored in this directory
		previous_plots = glob.glob(self.Storage_Path + self.Radiosonde_Plots_Path + path + "/*")
		
		#Find the biggest 'v' number in plots
		plot_version = []
		for plots in previous_plots:
			try:
				plot_version.append(int(os.path.basename(plots)[34:37]))
			except ValueError:
				plot_version.append(int(os.path.basename(plots)[34:36]))
		
		plot_version = str(np.max(plot_version)+1) if len(plot_version) != 0 else '1'
		
		#Create full directory and file name
		Save_Location = self.Storage_Path + self.Radiosonde_Plots_Path + path + '/' + path + '_v' + plot_version.rjust(2,'0') + '_' + str(self.height_range[0]).rjust(2,'0') + 'km_to_' + str(self.height_range[1]).rjust(2,'0') + 'km.png'
		
		#Ensure the directory exists on file system and save to that location
		gu.ensure_dir(os.path.dirname(Save_Location))
		Superplotter.savefig(Save_Location)
		
		if self.verbose is True: print("[INFO] Superplotter completed successfully (In %.2fs)" % (time.time()-t_begin))

	def Tephigram(self, plot_tephigram=False, plot_camborne=False):
		"""The Radiosonde_Tephigram function will plot a tephigram from the dry bulb temperature,
		T_dry and the Dew point Temperature, T_dew for pressure values, P at each corresponding 
		height. 
		
		Certain tephigram outputs are available from this function including:
		1) Lower Condensation Level (LCL) in m
		2) Level of Free Convection (LFC) in m
		3) Environmental Level (EL) in m
		4) Convective Available Potential Energy (CAPE) in J/kg
		5) Convective INhibition (CIN) in J/kg

		Parameters
		----------
		
		plot_tephigram : bool, optional, default is False
			Specify True to plot a tephigram of the sounding data. Otherwise
			just calculate the sounding indices
		plot_camborne : bool, optional, default is False
			Specify True to add the sounding from Camborne at the closest time
			to the launch time. Only used if plot_tephigram is True.
		
		Outputs
		-------
		
		References
		----------
		Ambaum, M. H. P., 2010. Water in the Atmosphere. In: Thermal Physics of the Atmosphere. Oxford: Wiley & Sons, pp. 93-109
		Marlton, G. 2018. Tephigram. Original Matlab code found in Matlab_Code directory
		Hunt, K. 2018. Tephigram. Original Python code found in the same directory.
		"""
		
		if self.verbose is True: gu.cprint("[INFO] You are running Radiosonde_Tephigram from the STABLE release", type='bold')
			
		############################################################################
		"""Prerequisites"""
		
		#Time Controls
		t_begin = time.time()
		
		#Set-up data importer
		EPCC_Data = EPCC_Importer()
		

		############################################################################
		"""[Step 1] Calibrate bespoke sensors"""
    
		#Return Data (make local to function only. i.e. DON'T use self.Radiosonde_Data)
		Radiosonde_Data = self.Radiosonde_Data['Counts'].copy()
		
		Z = Radiosonde_Data['height'][1:]
		Tdry = Radiosonde_Data['Tdry'][1:]
		Tdew = Radiosonde_Data['Tdew'][1:]
		Pres = Radiosonde_Data['P'][1:]
		RH = Radiosonde_Data['RH'][1:]/100; RH -= np.max(RH) - 0.01
		Wind_Mag = (Radiosonde_Data['u'][1:]**2 + Radiosonde_Data['v'][1:]**2)**0.5
		Wind_Dir = np.arctan2(Radiosonde_Data['u'][1:], Radiosonde_Data['v'][1:]) * 180 / np.pi
			
		############################################################################
		"""[Step 2] Create Tephigram"""
		
		if plot_tephigram is True:
		
			print("[INFO] Plotting Tephigram...")
		
			#Unpack variables
			Z_Plot = Radiosonde_Data['height']
			Tdry_Plot = Radiosonde_Data['Tdry']
			Tdew_Plot = Radiosonde_Data['Tdew']
			Pres_Plot = Radiosonde_Data['P']
			
			#Subset the tephigram to specified location
			locator = gu.argneararray(Z_Plot, np.array(self.height_range)*1000)
			anchor = np.array([(Pres_Plot[locator]),(Tdry_Plot[locator])]).T
			
			Pres_Plot_Antinan, Tdry_Plot_Antinan, Tdew_Plot_Antinan = gu.antinan(np.array([Pres_Plot, Tdry_Plot, Tdew_Plot]), unpack=True)
			
			#Group the dews, temps and wind profile measurements
			dews = zip(Pres_Plot_Antinan, Tdew_Plot_Antinan)
			temps = zip(Pres_Plot_Antinan, Tdry_Plot_Antinan)
			barb_vals = zip(Pres,Wind_Dir,Pres_Plot)
					
			#Create Tephigram plot
			Tephigram = SPTephigram()
			
			if plot_camborne is True:
				
				#Determine ULS data
				ULS_File = sorted(glob.glob(PhD_Global.Raw_Data_Path + 'Met_Data/ULS/*'))
				
				ULS_Date = np.zeros(len(ULS_File), dtype=object)
				for i, file in enumerate(ULS_File):
					try:
						ULS_Date[i] = datetime.strptime(os.path.basename(file), '%Y%m%d_%H_03808_UoW_ULS.csv')
					except:
						ULS_Date[i] = datetime(1900,1,1)
				
				#Find Nearest Upper Level Sounding Flight to Radiosonde Flight
				ID = gu.argnear(ULS_Date, self.Launch_Datetime)
				
				print("[INFO] Radiosonde Launch Time:", self.Launch_Datetime, "Camborne Launch Time:", ULS_Date[ID])
				
				#Import Camborne Radiosonde Data
				press_camborne, temps_camborne, dews_camborne = EPCC_Data.ULS_Calibrate(ULS_File[ID], unpack=True, PRES=True, TEMP=True, DWPT=True)
				
				#Match Camborne pressures with Reading pressures
				mask = [gu.argnear(press_camborne, Pres_Plot[0]), gu.argnear(press_camborne, Pres_Plot[-1])]
				press_camborne = press_camborne[mask[0]:mask[1]]
				temps_camborne = temps_camborne[mask[0]:mask[1]]
				dews_camborne = dews_camborne[mask[0]:mask[1]]
					
				dews_camborne = zip(press_camborne, dews_camborne)
				temps_camborne = zip(press_camborne, temps_camborne)
				
				#Plot Reading Radiosonde
				profile_t1 = Tephigram.plot(temps, color="red", linewidth=1, label='Reading Dry Bulb Temperature', zorder=5)
				profile_d1 = Tephigram.plot(dews, color="blue", linewidth=1, label='Reading Dew Bulb Temperature', zorder=5)
				
				#Plot Camborne Radiosonde
				profile_t1 = Tephigram.plot(temps_camborne, color="red", linestyle=':', linewidth=1, label='Camborne Dry Bulb Temperature', zorder=5)
				profile_d1 = Tephigram.plot(dews_camborne, color="blue", linestyle=':', linewidth=1, label='Camborne Dew Bulb Temperature', zorder=5)
			else:	
				profile_t1 = Tephigram.plot(temps, color="red", linewidth=2, **{'label':'Dry Bulb Temperature'})
				profile_d1 = Tephigram.plot(dews, color="blue", linewidth=2, **{'label':'Dew Bulb Temperature'})
			
			#Add extra information to Tephigram plot
			#Tephigram.axes.set(title=Title, xlabel="Potential Temperature $(^\circ C)$", ylabel="Dry Bulb Temperature $(^\circ C)$")
			Title = 'Radiosonde Tephigram Flight No.' + str(self.sensor_package) + ' (' + self.Launch_Datetime.strftime("%d/%m/%Y %H%MUTC") + ')' if self.GPS_File is not None else 'Radiosonde Tephigram Flight (N/A)'
			Tephigram.axes.set(title=Title)
					
			#[OPTIONAL] Add wind profile information to Tephigram.
			#profile_t1.barbs(barb_vals)
			
			############################################################################
			"""Save plot to file"""

			#Specify the directory the plots are stored in 
			path = os.path.dirname(self.Radiosonde_File).replace(self.Storage_Path + self.Processed_Data_Path,"")
			
			#Find any other plots stored in this directory
			previous_plots = glob.glob(self.Storage_Path + self.Tephigram_Plots_Path + path + "/*")
			
			#Find the biggest 'v' number in plots
			plot_version = []
			for plots in previous_plots:
				try:
					plot_version.append(int(os.path.basename(plots)[34:37]))
				except ValueError:
					plot_version.append(int(os.path.basename(plots)[34:36]))
			
			plot_version = str(np.max(plot_version)+1) if len(plot_version) != 0 else '1'
			
			#Create full directory and file name
			Save_Location = self.Storage_Path + self.Tephigram_Plots_Path + path + '/' + path + '_v' + plot_version.rjust(2,'0') + '_' + str(self.height_range[0]).rjust(2,'0') + 'km_to_' + str(self.height_range[1]).rjust(2,'0') + 'km.png'
			
			#Ensure the directory exists on file system and save to that location
			gu.ensure_dir(os.path.dirname(Save_Location))
			
			print("Save_Location", Save_Location)
			Tephigram.savefig(Save_Location)      

		############################################################################
		"""[Step 3] Calculate Stability Indices"""
		
		print("[INFO] Calculating Stability Indices...")
		
		#Common Pressure Levels
		P_500 = gu.argnear(Pres, 500)
		P_700 = gu.argnear(Pres, 700)
		P_850 = gu.argnear(Pres, 850)
		
		#Showalter stability index
		#S = Tdry[P_500] - Tl
		
		#K-Index
		K = (Tdry[P_850] - Tdry[P_500]) + Tdew[P_850] - (Tdry[P_700] - Tdew[P_700])
		
		#Cross Totals Index
		CT = Tdew[P_850] - Tdry[P_500]
		
		#Vertical Totals Index
		VT = Tdry[P_850] - Tdry[P_500]
		
		#Total Totals Index
		TT = VT + CT
		
		#SWEAT Index
		ms2kn = 1.94384	#Conversion between m/s to knots
			
		SW_1 = 20*(TT-49)
		SW_2 = 12*Tdew[P_850]
		SW_3 = 2*Wind_Mag[P_850]*ms2kn
		SW_4 = Wind_Mag[P_500]*ms2kn
		SW_5 = 125*(np.sin(Wind_Dir[P_500]-Wind_Dir[P_850]) + 0.2)
		
		#Condition SWEAT Term 1 from several conditions
		SW_1 = 0 if SW_1 < 49 else SW_1

		#Condition SWEAT Term 5 with several conditions
		if (Wind_Dir[P_850] > 130) & (Wind_Dir[P_850] < 250):
			if (Wind_Dir[P_500] > 210) & (Wind_Dir[P_500] < 310):
				if Wind_Dir[P_500]-Wind_Dir[P_850] > 0:
					if (Wind_Mag[P_500]*ms2kn > 15) & (Wind_Mag[P_850]*ms2kn > 15):
						SW_5 = SW_5
					else:
						SW_5 = 0
				else:
					SW_5 = 0
			else:
				SW_5 = 0
		else:
			SW_5 = 0
		
		#Calulate Final Product
		SW = SW_1 + SW_2 + SW_3 + SW_4 + SW_5
		
		print("Stability Indices")
		print("-----------------")
		print("K-Index:", K)
		print("Cross Totals Index:", CT)
		print("Vettical Totals Index:", VT)
		print("Total Totals Index:", TT)
		print("SWEAT Index:", SW)
		print("\n")
		
		############################################################################
		"""[Step 4] Calculate Tephigram Indices"""
		
		#Convert Temperature back to Kelvin
		Tdry += 273.15
		Tdew += 273.15
				
		#Convert Height into metres
		Z *= 1000
				
		print("Tdry", Tdry, Tdry.shape)
		print("Tdew", Tdew, Tdew.shape)
		print("Z", Z, Z.shape)
		
		
		#Constants
		over27 = 0.286 # Value used for calculating potential temperature 2/7
		L = 2.5e6  #Latent evaporation 2.5x10^6
		epsilon = 0.622
		E = 6.014  #e in hpa 
		Rd = 287 #R constant for dry air
		
		#Equations
		es = lambda T: 6.112*np.exp((17.67*(T-273.15))/(T-29.65)) #Teten's Formula for Saturated Vapour Pressure converted for the units of T in Kelvin rather than Centigrade
		
		#Calculate Theta and Theta Dew
		theta = Tdry*(1000/Pres)**over27
		thetadew = Tdew*(1000/Pres)**over27
			
		#Find the Lifting Condensation Level (LCL)
		qs_base = 0.622*es(Tdew[0])/Pres[0]
		
		theta_base = theta[0]
		Pqs_base = 0.622*es(Tdry)/qs_base  #Calculate a pressure for constant qs
		Pqs_base = Tdry*(1000/Pqs_base)**(2/7) #Calculates pressure in term of P temp
		
		#print("Tdew[0]", Tdew[0])
		#print("Pres[0]", Pres[0])
		#print("qs_base",qs_base)
		#print("theta_base", theta_base)
		#print("Pqs_base", Pqs_base)
		
		#Find first location where Pqs_base > theta_base
		y1 = np.arange(Pqs_base.size)[Pqs_base > theta_base][0]
		#print(Pqs_base[y1])
		#print(y1)
		#print(gu.argnear(Pqs_base, theta_base))
		
		LCL = Z[y1]
			
		Tarr = np.zeros(Tdry.size)
		thetaarr = np.zeros(Tdry.size)

		T_temp = Tdry[y1]
		P_temp = 1000*(T_temp/Pqs_base[y1])**3.5
		qs0 = 0.622*es(T_temp)/P_temp
		
		thetaarr[y1] = Pqs_base[y1]
		Tarr[y1] = T_temp
		
		for i in xrange(y1+1, y1+100):
			T_temp -= 1
			P_temp = 1000*(T_temp/thetaarr[i-1])**3.5
			qs = 0.622*es(T_temp)/P_temp
			thetaarr[i] = thetaarr[i-1] - ((2.5E6/1004)*(thetaarr[i-1]/T_temp) * (qs-qs0))
			qs0 = qs
			Tarr[i] = T_temp
			
		#Now need to integrate back to 1000hpa
		T_temp = Tdry[y1]
		P_temp = 1000*(T_temp/Pqs_base[y1])**3.5
		qs0 = 0.622*es(T_temp)/P_temp
		thetaarr[y1] = Pqs_base[y1]
		Tarr[y1] = T_temp
		for i in xrange(y1-1):
			T_temp += 1
			P_temp = 1000*(T_temp/thetaarr[(y1-i)+1])**3.5
			qs = 0.622*es(T_temp)/P_temp
			thetaarr[y1-i] = thetaarr[(y1-i)+1] - ((2.5E6/1004)*(thetaarr[(y1-i)+1]/T_temp) * (qs-qs0))
			qs0 = qs
			Tarr[y1-i] = T_temp
		
		y8 = (thetaarr>253) & (thetaarr<380)
		thetaarr = thetaarr[y8]
		Tarr = Tarr[y8]
		
		#Now find environmental levels and LFC begin by converting thetaarr into P
		Pthetaeq = 1000/(thetaarr/Tarr)**3.5
		l5 = np.isnan(Pthetaeq)
		Pthetaeq[l5] = []
		
		#Now interpolate on to rs height co-ordinates	
		TEMP = sp.interpolate.interp1d(Pthetaeq,[thetaarr,Tarr], fill_value="extrapolate")(Pres)
		thetaarr = TEMP[0]
		Tarr = TEMP[1]

		del(TEMP)
		
		
		
		y5 = np.arange(Tdry.size)[Tdry < Tarr]
		
		print("y5", y5)
		
		if np.any(y5):
			LFC = Z[y5[0]]
			EL = Z[y5[-1]]
			
			#Finds CIN area above LCL
			y6 = np.arange(Tdry.size)[(Z < LFC) & (Z >= LCL) & (Tdry > Tarr)]
			y7 = np.arange(Tdry.size)[(Z < LCL) & (Tdry > Tarr)]
			
			Pstart = Pres[y5[-1]]
			
			#Now need to calculate y5 temperatures into virtual temperatures
			Tvdash = Tarr/(1-(E/Pres)*(1-epsilon))
			Tv = Tdry/(1-(E/Pres)*(1-epsilon))
			T_adiabat = ((theta_base/(1000/Pres)**over27))
			Tv_adiabat = T_adiabat/(1-(E/Pres)*(1-epsilon))
			
			#Now need to calculate CAPE... and CIN to use CAPE = R_d = intergral(LFC,EL)(T'_v - T_v) d ln p
			CAPE = 0
			for i in xrange(y5[-2], y5[0], -1):
				CAPE += (Rd*(Tvdash[i] - Tv[i]) * np.log(Pres[i]/Pres[i+1]));
			
			#Now we use same technique to calculate CIN
			CIN=0;
			if len(y6) != 0:
				for i in xrange(y6[-2], y6[0], -1):
					CIN += (Rd*(Tvdash[i] - Tv[i]) * np.log(Pres[i]/Pres[i+1]))
		
			#Now calculate temperature along the dry adiabat
			y7 = np.arange(Tdry.size)[(Z < LCL) & (Tv > Tv_adiabat)]
			if len(y7) != 0:
				for i in xrange(y7[-2], y7[0], -1): 
					CIN += (Rd*(Tv_adiabat[i] - Tv[i]) * np.log(Pres[i]/Pres[i+1]));   
			
		else:
			LFC = np.nan
			EL = np.nan
			CAPE = 0
			CIN = 0
		
		#Print out information
		print("Parcel Information")
		print("------------------")
		print("LCL = %.2fm" % LCL)
		print("LFC = %.2fm" % LFC)
		print("EL = %.2fm" % EL)
		print("CAPE %.2f J/kg" % CAPE)
		print("CIN %.2f J/kg" % CIN)
		print("\n")
		
		print("[INFO] Radiosonde_Tephigram has been completed successfully (In %.2fs)" % (time.time()-t_begin))
		
		return LCL, LFC, EL, CAPE, CIN		
	
	def PointCharge(self):
		"""HYPOTHESIS 2: The charge present within a convective cloud is proportional to the 
		change in PG measured at the surface."""
		
		if self.verbose is True: gu.cprint("[INFO] You are running PointCharge from the DEV release", type='bold')
		
		############################################################################
		"""Prerequisites"""
		
		#Time Controls
		t_begin = time.time()
		
		#Constants
		k 			= 2500000/22468879568420441	#Coulombs Constant (exact value!)
		kn2ms		= 0.5144					#Conversion between knots and m/s
		
		#Radiosonde Data
		Radiosonde_Data = self.Radiosonde_Data['Units'].copy()
		
		#Set-up data importer
		EPCC_Data = EPCC_Importer()
		
		############################################################################
		
		#Get cloud base and cloud top heights for each identified cloud
		Cloud_Heights = np.array([[Radiosonde_Data['height'][self.Clouds_ID == Cloud][0], 
			Radiosonde_Data['height'][self.Clouds_ID == Cloud][-1]] if self.LayerType[self.Clouds_ID == Cloud][0] == 2 else None for Cloud in np.unique(self.Clouds_ID)[1:]], 
			dtype=np.float64)
		
		#Get index of lowest cloud
		CloudIndex = gu.searchsorted(Radiosonde_Data['height'], Cloud_Heights[0])
		
		elem = 1
		
		#Find total charge
		Cloud_SpaceChargeDensity = Radiosonde_Data['SpaceCharge'][CloudIndex[0]:CloudIndex[1]]/10**12
		Cloud_AscentArea = np.diff(Radiosonde_Data['height'][CloudIndex[0]:CloudIndex[1]+1])*1000#/np.diff(Radiosonde_Data['time'][CloudIndex[0]:CloudIndex[1]+1])
		Cloud_Charge = gu.interavg(Cloud_SpaceChargeDensity, elem, type='nansum') * 10**7*gu.interavg(Cloud_AscentArea, elem, type='nansum')
		
		gu.stats(Cloud_Charge, output=True)
		
		#Get Cloud Height [m]
		Cloud_Height = gu.interavg(Radiosonde_Data['height'][CloudIndex[0]:CloudIndex[1]]*1000, elem, type='nanmean')
		
		#Get Cloud Velocity [m/s]
		Cloud_Velocity = gu.interavg(np.sqrt(Radiosonde_Data['u']**2+Radiosonde_Data['v']**2)[CloudIndex[0]:CloudIndex[1]], elem, type='nanmean')
		
		#Get Cloud Time
		Cloud_Time = self.LaunchTime[self.sensor_package]
		Cloud_Date = Cloud_Time.astype('datetime64[D]')
		Cloud_BaseTime = Cloud_Time + np.timedelta64(int(Radiosonde_Data['time'][CloudIndex[0]]), 's')
		
		#Get Cloud Time Difference
		Cloud_TimeDiff = gu.interavg(Radiosonde_Data['time'][CloudIndex[0]:CloudIndex[1]], elem, type='nanmean')
		Cloud_TimeDiff -= Cloud_TimeDiff[0]
		
		#Calculate Electric Field
		print(Cloud_Height.shape, Cloud_Velocity.shape, Cloud_Charge.shape)
		
		Cloud_Time = np.arange(-2000, 2000, 10)
		
		Cloud_ElectricField = np.array([(gu.cosarctan(((Cloud_Time+time_diff)*velocity)/height)*charge)/(k*height**2) for time_diff, height, velocity, charge in zip(Cloud_TimeDiff, Cloud_Height, Cloud_Velocity, Cloud_Charge)])
		
		print("Cloud_ElectricField", Cloud_ElectricField.shape)
		
		Cloud_ElectricField_Total = 100 + np.nansum(Cloud_ElectricField, axis=0)
		
		print("Cloud_ElectricField_Total", Cloud_ElectricField_Total.shape)
		
		#Calculate datetimes for each calculation in Cloud_ElectricField
		Cloud_DateTime = Cloud_BaseTime + Cloud_Time.astype('timedelta64[s]')
		
		#Import PG data
		ID = np.where(Data['Date_ID'] == Cloud_BaseTime.astype('datetime64[D]').astype('datetime64[s]').astype(datetime))[0][0]
		Field_Mill_Time, Field_Mill_PG = EPCC_Data.FieldMill_Calibrate(self.data['FieldMill_RUAO_1sec_Processed_File'][ID])
		
		#Plot the data
		gu.backend_changer()
		
		plt.close()
		plt.clf()
		
		f, ax1 = plt.subplots()
		
		ax1.plot(Cloud_DateTime, Cloud_ElectricField_Total)
		
		ax2 = ax1.twinx()
		Field_Mill_Time = gu.addHourFrac(Cloud_Date, Field_Mill_Time)
		print("Field_Mill_Time", Field_Mill_Time)
		ax2.plot(Field_Mill_Time, Field_Mill_PG, lw=0.5, color='black')
		
		ax1.grid(which='major',axis='both',c='grey')
		ax1.set_xlabel('Time (Hour)')
		ax1.set_ylabel('Estimated Potential Gradient (V/m)')
		ax2.set_ylabel('Measured Potential Gradient (V/m)')
		
		ax1.set_xlim(np.min(Cloud_DateTime), np.max(Cloud_DateTime))
		ax2.set_xlim(np.min(Cloud_DateTime), np.max(Cloud_DateTime))

		ax1.set_ylim(np.nanmin(gu.flatten([Cloud_ElectricField_Total,Field_Mill_PG])), np.nanmax(gu.flatten([Cloud_ElectricField_Total,Field_Mill_PG])))
		ax2.set_ylim(np.nanmin(gu.flatten([Cloud_ElectricField_Total,Field_Mill_PG])), np.nanmax(gu.flatten([Cloud_ElectricField_Total,Field_Mill_PG])))
		ax1.xaxis.set_major_formatter(DateFormatter('%H:%M'))
		
		ax1.get_yaxis().get_major_formatter().set_useOffset(False)
		ax1.get_yaxis().get_major_formatter().set_scientific(False)
		
		#plt.gcf().set_size_inches((11.7/6), 8.3)
		
		plt.show()
	
		sys.exit()
	
	def ChargeOpticalCorrelation(self):
		"""HYPOTHESIS 3: The charge present within a convective clouds has a positive correlation 
		with optical thickness caused by an increase in the hydrometeor collision efficiency which 
		in turn increases the amount of charge separation."""
		
		if self.verbose is True: gu.cprint("[INFO] You are running PointCharge from the DEV release", type='bold')
		
		############################################################################
		"""Prerequisites"""
		
		#Time Controls
		t_begin = time.time()
		
		#Radiosonde Data
		Radiosonde_Data = self.Radiosonde_Data['Units'].copy()
		
		#Set-up data importer
		EPCC_Data = EPCC_Importer()
		
		#Set-up plotting
		gu.backend_changer()
		
		#Conditionals
		section1 = True
		section2 = False
		
		############################################################################
		#Get cloud base and cloud top heights for each identified cloud
		
		#Get cloud base and cloud top heights for each identified cloud
		Cloud_Heights = np.array([[Radiosonde_Data['height'][self.Clouds_ID == Cloud][0], Radiosonde_Data['height'][self.Clouds_ID == Cloud][-1]] for Cloud in np.unique(self.Clouds_ID)[1:]], dtype=np.float64)
		
		Clear_Heights = [[0,Cloud_Heights[0,0]]]
		for i in xrange(Cloud_Heights.shape[0]-1):
			Clear_Heights.append([Cloud_Heights[i,1], Cloud_Heights[i+1,0]])
		Clear_Heights.append([Cloud_Heights[-1,1], self.height_range[1]])
		Clear_Heights = np.array(Clear_Heights)
		
		print("Cloud_Heights")
		print(Cloud_Heights)
		
		if section1 is True:
			############################################################################
			"""[SECTION 1] Space Charge vs. IR"""
			
			#Remove nan's from data
			Time, Height, SpaceCharge, IR  = gu.antifinite((Radiosonde_Data['time'], 
				Radiosonde_Data['height'],
				np.abs(Radiosonde_Data['SpaceCharge']),
				Radiosonde_Data['IR']-Radiosonde_Data['Cyan']), 
				unpack=True)
			
			Cloud_SpaceCharge = gu.array()
			Cloud_IR = gu.array()
			for cloud in [Cloud_Heights[0]]:
			
				#Get index of lowest cloud
				CloudIndex = gu.searchsorted(Height, cloud)
			
				#Subset data
				SpaceCharge_Subset = SpaceCharge[CloudIndex[0]:CloudIndex[1]]
				IR_Subset = IR[CloudIndex[0]:CloudIndex[1]]
				
				#Add to master array
				Cloud_SpaceCharge.update([SpaceCharge_Subset])
				Cloud_IR.update([IR_Subset])
			
			#Finalize arrays
			Cloud_SpaceCharge = Cloud_SpaceCharge.finalize(dtype=np.float64)/1000
			Cloud_IR = Cloud_IR.finalize(dtype=np.float64)
			
			mask = Cloud_IR < 5
			Cloud_SpaceCharge = Cloud_SpaceCharge[mask]
			Cloud_IR = Cloud_IR[mask]
			
			#LR_IRSC = sp.stats.linregress(Cloud_SpaceCharge, Cloud_IR)
			LR_IRSC = gu.HuberRegression(Cloud_SpaceCharge, Cloud_IR)
			
			print("LR_IRSC", LR_IRSC)
			print("Correlation", sp.stats.spearmanr(Cloud_SpaceCharge, Cloud_IR)[0])
			
			filename = self.Storage_Path + 'Plots/Hypothesis_3/CrossCorrelation_SpaceCharge_IRdiffCyan_RadiosondeNo.' + str(self.sensor_package).rjust(2,"0") + '.png'
			Cloud_SpaceCharge_Best, Cloud_IR_Best = CrossCorrelation_Scatter_Plot(
				Cloud_SpaceCharge, 
				Cloud_IR, 
				filename=filename, 
				xlabel="Space Charge (nC m$^{-3}$)", 
				ylabel="IR - Cyan Cloud Sensor (V)", 
				title="Cross Correlation (Radiosonde No." + str(self.sensor_package) + ")",
				xlim='auto',
				ylim=[0,'auto'],
				xscale="linear",
				yscale="linear",
				verbose=True)
			
			#LR_IRSC2 = sp.stats.linregress(Cloud_SpaceCharge_Best,Cloud_IR_Best)
			LR_IRSC2 = gu.HuberRegression(Cloud_SpaceCharge_Best,Cloud_IR_Best)
		
			print("LR_IRSC2", LR_IRSC2)
			print("Correlation", sp.stats.spearmanr(Cloud_SpaceCharge_Best, Cloud_IR_Best)[0])
		
			sys.exit()
		
		if section2 is True:
			############################################################################
			"""[SECTION 2] Space Charge Fluctuations"""
			
			#Remove nan's from data
			Time, Height, SpaceCharge  = gu.antifinite((Radiosonde_Data['time'], 
				Radiosonde_Data['height'],
				Radiosonde_Data['SpaceCharge']/1000), 
				unpack=True)
			
			#Detect sign changes in data
			SignChange = np.where(np.diff(np.sign(SpaceCharge)))[0]

			print(SignChange)
			
			Cloud_SignChange_All = gu.array()
			Cloud_SpaceCharge_All = gu.array()
			for cloud in Cloud_Heights:
			
				#Get index of lowest cloud
				CloudIndex = gu.searchsorted(Height, cloud)
				
				#Get SignChange position for cloud
				Cloud_SignChange = SignChange[(SignChange >= CloudIndex[0]) & (SignChange <= CloudIndex[1])]
				
				#Get time stamps of sign change
				Cloud_TimeChange = Time[Cloud_SignChange]
				
				#Get Space Charge
				Spacing = gu.broadcast(Cloud_SignChange,2,1)
				Cloud_SpaceCharge = np.array([np.nanmean(np.abs(SpaceCharge[space[0]:space[1]])) for space in Spacing])
					
				#Get difference
				Cloud_SignChange_All.update([np.diff(Cloud_TimeChange)])
				Cloud_SpaceCharge_All.update([Cloud_SpaceCharge])
				
			Air_SignChange_All = gu.array()
			Air_SpaceCharge_All = gu.array()
			for air in Clear_Heights:
			
				#Get index of lowest cloud
				AirIndex = gu.searchsorted(Height, air)
				
				#Get SignChange position for cloud
				Air_SignChange = SignChange[(SignChange >= AirIndex[0]) & (SignChange <= AirIndex[1])]
				
				#Get time stamps of sign change
				Air_TimeChange = Time[Air_SignChange]
				
				#Get Space Charge
				Spacing = gu.broadcast(Air_SignChange,2,1)
				Air_SpaceCharge = np.array([np.nanmean(np.abs(SpaceCharge[space[0]:space[1]])) for space in Spacing])
					
				#Get difference
				Air_SignChange_All.update([np.diff(Air_TimeChange)])
				Air_SpaceCharge_All.update([Air_SpaceCharge])
			
			#Finalise arrays
			Cloud_SignChange_All = Cloud_SignChange_All.finalize(dtype=np.float64)
			Cloud_SpaceCharge_All = Cloud_SpaceCharge_All.finalize(dtype=np.float64)
			Air_SignChange_All = Air_SignChange_All.finalize(dtype=np.float64)
			Air_SpaceCharge_All = Air_SpaceCharge_All.finalize(dtype=np.float64)
			
			#Anderson-Darling Test
			print(sp.stats.anderson_ksamp((Cloud_SignChange_All, Air_SignChange_All)))
			
			#Linear Regressions
			print(sp.stats.linregress(Cloud_SignChange_All, Cloud_SpaceCharge_All))
			print(sp.stats.linregress(Air_SignChange_All, Air_SpaceCharge_All))
			print(sp.stats.linregress(np.hstack((Cloud_SignChange_All, Air_SignChange_All)), 
				np.hstack((Cloud_SpaceCharge_All, Air_SpaceCharge_All))))
			
			
			plt.clf()
			plt.close()
			f, ax = plt.subplots(1, 2)
			
			#Set global properties before the plotting of data
			for subplot in ax: subplot.grid(which='major',axis='both',c='grey')
			f.subplots_adjust(wspace=0)
			ax[1].axes.tick_params(left='off')
			
			#Plot data			
			ax[0].plot(Cloud_SignChange_All, Cloud_SpaceCharge_All, 'ko')
			ax[1].plot(Air_SignChange_All, Air_SpaceCharge_All, 'ko')
			
			ax[0].set_xlabel("Time between Polarity Changes (s)")
			ax[0].set_ylabel("Space Charge Density (nC m$^{-3}$)")
			ax[1].set_xlabel("Time between Polarity Changes (s)")
			
			all_xdata = np.hstack((Cloud_SignChange_All, Air_SignChange_All))
			all_ydata = np.hstack((Cloud_SpaceCharge_All, Air_SpaceCharge_All))
			ax[0].set_xlim([np.nanmin(all_xdata), np.nanmax(all_xdata)])
			ax[0].set_ylim([np.nanmin(all_ydata), np.nanmax(all_ydata)])
			ax[1].set_xlim([np.nanmin(all_xdata), np.nanmax(all_xdata)])
			ax[1].set_ylim([np.nanmin(all_ydata), np.nanmax(all_ydata)])
			
			#Calculate Linear Regression Models
			Cloud_lm = sp.stats.linregress(Cloud_SignChange_All, Cloud_SpaceCharge_All)
			Air_lm = sp.stats.linregress(Air_SignChange_All, Air_SpaceCharge_All)
			
			#Annotate the scatter plot
			ax[0].annotate("Counts = %.0f\nR Value = %.4f" % (np.size(Cloud_SignChange_All), Cloud_lm[2]), xy=(1, 1), xycoords='axes fraction', xytext=(-20, -20), textcoords='offset pixels', horizontalalignment='right', verticalalignment='top', fontsize=10)
			ax[1].annotate("Counts = %.0f\nR Value = %.4f" % (np.size(Air_SignChange_All), Air_lm[2]), xy=(1, 1), xycoords='axes fraction', xytext=(-20, -20), textcoords='offset pixels', horizontalalignment='right', verticalalignment='top', fontsize=10)
			
			#Remove y axis on right-hand plot
			gu.hide_axis(ax=ax[1], x_or_y='y')
			
			#Set global properties after the plotting of data
			for subplot in ax: gu.fixed_aspect_ratio(ax=subplot, ratio=1, adjustable=None)

			#Save figure
			filename = self.Storage_Path + 'Plots/Hypothesis_3/SpaceCharge_Variability_PolarityChanges_RadiosondeNo.' + \
				str(self.sensor_package).rjust(2,"0") + '.png'
			plt.savefig(filename, bbox_inches='tight', pad_inches=0.1, dpi=300)
			
			sys.exit()
			
			
			fontsize = 10
			
			plt.clf()
			plt.close()
			f, ax = plt.subplots(1, 2, sharey=True)

			#f.suptitle(title, va='top', fontsize=fontsize)
			for subplot in ax: subplot.minorticks_on()
			for subplot in ax: subplot.grid(which='major',axis='both',c='grey')

			f.subplots_adjust(wspace=0)

			#Set axis parameters
			f.text(0.5, 0.04, 'Counts', ha='center', fontsize=fontsize)
			ax[0].set_ylabel("Coefficient of Variation", fontsize=fontsize)
			fill_kwargs = {'lw':0.0, 'edgecolor':None}
			
			#Plot Histograms
			hist1_plot = ax[0].hist(gu.antinan(Cloud_SignChange_All), bins=100, orientation='horizontal', rwidth=0.8, label='All Rain', histtype='stepfilled', color='purple', **fill_kwargs)
			hist2_plot = ax[1].hist(gu.antinan(Air_SignChange_All), bins=100, orientation='horizontal', rwidth=0.8, label='Charged Rain', histtype='stepfilled', color='deepskyblue', **fill_kwargs)
			
			ax[0].set_xscale("linear")
			ax[1].set_xscale("linear")
			
			ax[0].set_xlim([0, np.nanmax([hist1_plot[0], hist2_plot[0]])])
			ax[1].set_xlim([0, np.nanmax([hist1_plot[0], hist2_plot[0]])])

			#Invert x-axis for ax[0]
			ax[0].invert_xaxis()

			#Annotate the plots
			#Names
			ax[0].annotate("Cloud", xy=(0, 1), xycoords='axes fraction', xytext=(20, -20), textcoords='offset pixels', horizontalalignment='left', verticalalignment='top', fontsize=fontsize)
			ax[1].annotate("Clear-Air", xy=(0, 1), xycoords='axes fraction', xytext=(20, -20), textcoords='offset pixels', horizontalalignment='left', verticalalignment='top', fontsize=fontsize)
			
			#Counts
			ax[0].annotate("Counts = %.0f" % np.size(Cloud_SignChange_All), xy=(1, 1), xycoords='axes fraction', xytext=(-20, -20), textcoords='offset pixels', horizontalalignment='right', verticalalignment='top', fontsize=fontsize)
			ax[1].annotate("Counts = %.0f" % np.size(Air_SignChange_All), xy=(1, 1), xycoords='axes fraction', xytext=(-20, -20), textcoords='offset pixels', horizontalalignment='right', verticalalignment='top', fontsize=fontsize)
			
			plt.show()
		
			
		sys.exit()
		
		############################################################################
		
		#Get cloud base and cloud top heights for each identified cloud
		Cloud_Heights = np.array([[Radiosonde_Data['height'][self.Clouds_ID == Cloud][0], Radiosonde_Data['height'][self.Clouds_ID == Cloud][-1]] for Cloud in np.unique(self.Clouds_ID)[1:]], dtype=np.float64)
		
		print("Cloud_Heights", Cloud_Heights, Cloud_Heights.shape)
		
		Clear_Heights = [[0,Cloud_Heights[0,0]]]
		for i in xrange(Cloud_Heights.shape[0]-1):
			Clear_Heights.append([Cloud_Heights[i,1], Cloud_Heights[i+1,0]])
		Clear_Heights.append([Cloud_Heights[-1,1], self.height_range[1]])
		Clear_Heights = np.array(Clear_Heights)
		
		print("Clear_Heights", Clear_Heights, Clear_Heights.shape)
		#print("Clear_Heights", Clear_Heights)
		
		print("######CLOUDS#######")
		Time_Cloud = []
		CV_Cloud = []
		for cloud in Cloud_Heights:
			
			Time, Height, SLWC, SpaceCharge  = gu.antifinite((Radiosonde_Data['time'], Radiosonde_Data['height'], Radiosonde_Data['IR'], Radiosonde_Data['SpaceCharge']), unpack=True)
			
			#Get index of lowest cloud
			CloudIndex = gu.searchsorted(Height, cloud)
			
			Time = Time[CloudIndex[0]:CloudIndex[1]]
			SpaceCharge = SpaceCharge[CloudIndex[0]:CloudIndex[1]]
			SLWC = SLWC[CloudIndex[0]:CloudIndex[1]]
			
			CV_Cloud.append(SpaceCharge)
			Time_Cloud.append(Time)
			#CV_Cloud.append(np.nanstd(SpaceCharge)/np.nanmedian(SpaceCharge))
			#print("Cloud CV", np.nanstd(SpaceCharge)/np.nanmedian(SpaceCharge))

			#print(SLWC.shape, SpaceCharge.shape)
			#print(sp.stats.linregress(SLWC, SpaceCharge))
		
		print("######CLEAR AIR#######")
		Time_Air = []
		CV_Air = []
		for air in Clear_Heights:
			
			Time, Height, SLWC, SpaceCharge  = gu.antifinite((Radiosonde_Data['time'], Radiosonde_Data['height'], Radiosonde_Data['IR'], Radiosonde_Data['SpaceCharge']), unpack=True)
			
			#Get index of lowest cloud
			CloudIndex = gu.searchsorted(Height, air)
			
			Time = Time[CloudIndex[0]:CloudIndex[1]]
			SpaceCharge = SpaceCharge[CloudIndex[0]:CloudIndex[1]]
			SLWC = SLWC[CloudIndex[0]:CloudIndex[1]]
			
			CV_Air.append(SpaceCharge)
			Time_Air.append(Time)
			#CV_Air.append(np.nanstd(SpaceCharge)/np.nanmedian(SpaceCharge))
			#print("Cloud CV", np.nanstd(SpaceCharge)/np.nanmedian(SpaceCharge))
			
		print("######EQUAL SPACING#######")		
		Height, SLWC, SpaceCharge  = gu.antifinite((Radiosonde_Data['height'], Radiosonde_Data['IR'], np.abs(Radiosonde_Data['SpaceCharge'])), unpack=True)
		
		Cloud_Mask = gu.broadcast(np.searchsorted(Height, np.arange(0,15,0.2)),2,1)
		H = []
		CV = []	
		for cloud in Cloud_Mask:
			
			SpaceCharge_Temp = SpaceCharge[cloud[0]:cloud[1]].copy()
			
			H.append(np.nanmedian(Height[cloud[0]:cloud[1]]))
			CV.append(np.nanstd(SpaceCharge_Temp)/np.nanmean(SpaceCharge_Temp))
			#print("Cloud CV", np.nanstd(SpaceCharge_Temp)/np.nanmedian(SpaceCharge_Temp))
		
		#For clouds
		#mask = SLWC > 0.03
		#CV_Cloud = SpaceCharge[mask]
		
		#For clear-air
		#mask = SLWC < 0.03
		#CV_Air = SpaceCharge[mask]
		
		print("Time_Cloud", len(Time_Cloud))
		print("CV_Cloud", len(CV_Cloud))
		Time_Cloud, CV_Cloud = gu.antival((gu.flatten(Time_Cloud), gu.flatten(CV_Cloud)), val=0, unpack=True)
		Time_Air, CV_Air = gu.antival((gu.flatten(Time_Air), gu.flatten(CV_Air)), val=0, unpack=True)
		f = np.linspace(0.01, 1, 10000)
		
		print("CV_Cloud", CV_Cloud.shape)
		print("CV_Air", CV_Air.shape)
		
		Pxx_den1 = sp.signal.lombscargle(Time_Cloud, CV_Cloud, f)
		print("CV_Cloud FFT", f[np.argmax(Pxx_den1)])
				
		Pxx_den2 = sp.signal.lombscargle(Time_Air, CV_Air, f)
		print("CV_Air FFT", f[np.argmax(Pxx_den2)])
		
		plt.clf()
		plt.loglog(f, np.sqrt(4*(Pxx_den1/Time_Cloud.shape[0])), color='dodgerblue')
		plt.loglog(f, np.sqrt(4*(Pxx_den2/Time_Cloud.shape[0])), color='purple')
		plt.ylim([1e-3, 1e2])
		plt.xlabel('frequency [Hz]')
		plt.ylabel('PSD [V**2/Hz]')
		
		plt.grid(which='major',axis='both',c='grey')
		
		
		plt.savefig("FFT.png", bbox_inches='tight', pad_inches=0.1, dpi=300)
		
		
		sys.exit()
		
		H, CV = gu.antinan((H, CV), unpack=True)
		print(sp.stats.linregress(CV, H))
		print(sp.stats.levene(CV_Cloud, CV_Air))
		
		
		plt.clf()
		plt.close()		
		
		plt.plot(CV,H)
		
		plt.xlabel("Coefficient of Variation")
		plt.ylabel("Height (km)")

		for cloud in Cloud_Heights: plt.axhspan(*cloud, facecolor='black', alpha=0.3)
		
		plt.grid(which='major',axis='both',c='grey')
		
		plt.show()
		#sys.exit()
		#############################
		
		fontsize = 10
		
		plt.clf()
		plt.close()
		f, ax = plt.subplots(1, 2, sharey=True)

		#f.suptitle(title, va='top', fontsize=fontsize)
		for subplot in ax: subplot.minorticks_on()
		for subplot in ax: subplot.grid(which='major',axis='both',c='grey')

		f.subplots_adjust(wspace=0)

		#Set axis parameters
		f.text(0.5, 0.04, 'Counts', ha='center', fontsize=fontsize)
		ax[0].set_ylabel("Coefficient of Variation", fontsize=fontsize)
		fill_kwargs = {'lw':0.0, 'edgecolor':None}
		
		#Plot Histograms
		hist1_plot = ax[0].hist(gu.antinan(CV_Cloud), bins=100, orientation='horizontal', rwidth=0.8, label='All Rain', histtype='stepfilled', color='purple', **fill_kwargs)
		hist2_plot = ax[1].hist(gu.antinan(CV_Air), bins=100, orientation='horizontal', rwidth=0.8, label='Charged Rain', histtype='stepfilled', color='deepskyblue', **fill_kwargs)
		
		ax[0].set_xscale("linear")
		ax[1].set_xscale("linear")
		
		ax[0].set_xlim([0, np.nanmax([hist1_plot[0], hist2_plot[0]])])
		ax[1].set_xlim([0, np.nanmax([hist1_plot[0], hist2_plot[0]])])

		#ax[0].set_ylim([0,4])
		#ax[1].set_ylim([0,4])
		
		#ax[0].set_xlim([0,22])
		#ax[1].set_xlim([0,22])
		
		#Invert x-axis for ax[0]
		ax[0].invert_xaxis()

		#Annotate the plots
		#Names
		ax[0].annotate("Cloud", xy=(0, 1), xycoords='axes fraction', xytext=(20, -20), textcoords='offset pixels', horizontalalignment='left', verticalalignment='top', fontsize=fontsize)
		ax[1].annotate("Clear-Air", xy=(0, 1), xycoords='axes fraction', xytext=(20, -20), textcoords='offset pixels', horizontalalignment='left', verticalalignment='top', fontsize=fontsize)
		
		#Counts
		ax[0].annotate("Counts = %.0f" % np.size(CV_Cloud), xy=(1, 1), xycoords='axes fraction', xytext=(-20, -20), textcoords='offset pixels', horizontalalignment='right', verticalalignment='top', fontsize=fontsize)
		ax[1].annotate("Counts = %.0f" % np.size(CV_Air), xy=(1, 1), xycoords='axes fraction', xytext=(-20, -20), textcoords='offset pixels', horizontalalignment='right', verticalalignment='top', fontsize=fontsize)
		
		plt.show()
		
		#####################################
		sys.exit()		
		
		gu.backend_changer()
		lags, c, _, _ = plt.xcorr(SLWC, SpaceCharge, maxlags=None)
		
		plt.show()
		plt.clf()
		plt.close()
		
		#SLWC = SLWC[lags[np.argmax(c)]:]
		#SpaceCharge = SpaceCharge[:-lags[np.argmax(c)]]
		
		#print(sp.stats.linregress(SLWC, SpaceCharge))
		
		plt.plot(SLWC, SpaceCharge, 'ko')
		#plt.xscale('log')
		#plt.yscale('log')
		plt.show()
		sys.exit()
		
		
	def RH_Comparison(self):
		"""This function will plot the relative humidity with respects to ice using various
		calculations of the saturated vapour pressure
		
		"""
		
		if self.verbose is True: gu.cprint("[INFO] You are running RH_Comparison from the DEV release", type='bold')
		
		############################################################################
		"""Prerequisites"""
		
		#Time Controls
		t_begin = time.time()
				
		############################################################################
		"""[Step 1] Calibrate bespoke sensors"""

		#Calibrate Height, Temperature and Convert PANDORA channels from counts to volts if required.
		Radiosonde_Cal = Radiosonde_Checks(self.Radiosonde_Data.copy(), None, self.sensor_package, self.height_range, check=1111)
		Radiosonde_Cal_Goff = Radiosonde_Checks(self.Radiosonde_Data.copy(), None, self.sensor_package, self.height_range, check=1111)
		Radiosonde_Cal_Buck = Radiosonde_Checks(self.Radiosonde_Data.copy(), None, self.sensor_package, self.height_range, check=1111)
		Radiosonde_Cal_Wexler = Radiosonde_Checks(self.Radiosonde_Data.copy(), None, self.sensor_package, self.height_range, check=1111)
		Radiosonde_Cal_Sonntag = Radiosonde_Checks(self.Radiosonde_Data.copy(), None, self.sensor_package, self.height_range, check=1111)
	
		#Calibrate Relative Humidity Sensor (e.g. find RH_ice)
		Radiosonde_Cal_Goff.RH(method='goff')
		Radiosonde_Cal_Buck.RH(method='arden-buck')
		Radiosonde_Cal_Wexler.RH(method='wexler')
		Radiosonde_Cal_Sonntag.RH(method='sonntag')
		
		#Return Data (make local to function only. i.e. DON'T use self.Radiosonde_Data)
		Radiosonde_Data = Radiosonde_Cal.finalise()
		Radiosonde_Data_Goff = Radiosonde_Cal_Goff.finalise()
		Radiosonde_Data_Buck = Radiosonde_Cal_Buck.finalise()
		Radiosonde_Data_Wexler = Radiosonde_Cal_Wexler.finalise()
		Radiosonde_Data_Sonntag = Radiosonde_Cal_Sonntag.finalise()
		
		############################################################################
		"""[Step 2] Plot radiosonde data"""
		
		Title = 'Radiosonde Flight No.' + str(self.sensor_package) + ' (' + self.Launch_Datetime.strftime("%d/%m/%Y %H%MUTC") + ')' if self.GPS_File is not None else 'Radiosonde Flight (N/A)'
		
		Height = Radiosonde_Data[:,1]
		Temperature = Radiosonde_Data[:,3]
		RH = Radiosonde_Data[:,4]
		
		#Plotting requirements
		plt.style.use('classic') #necessary if Matplotlib version is >= 2.0.0

		#Make sure we are creating new plot from scratch
		plt.clf()
		plt.close()
		
		#Define number of subplots sharing y axis
		f, ax1 = plt.subplots()

		ax1.minorticks_on()
		ax1.grid(which='major',axis='both',c='grey')

		#Rotate xticks in all subplots
		for tick in ax1.get_xticklabels(): tick.set_rotation(90)
		
		#Remove random junk from the plot
		f.subplots_adjust(hspace=0)
		plt.setp([a.get_yticklabels() for a in f.axes[1:]], visible=False)
		
		#Set axis parameters
		ax1.set_ylabel('Height $(km)$')
		ax1.set_ylim([np.nanmin(Radiosonde_Data[:,1]), np.nanmax(Radiosonde_Data[:,1])])
		
		#Define plot size
		f.set_size_inches(8, 8)
		
		#Plot RH
		ax1.plot(RH, Height, label='Original', lw=0.5)
		ax1.plot(Radiosonde_Data_Goff[:,-1], Radiosonde_Data_Goff[:,1], label='Goff-Gratch', lw=0.5)
		ax1.plot(Radiosonde_Data_Buck[:,-1], Radiosonde_Data_Buck[:,1], label='Arden-Buck', lw=0.5)
		ax1.plot(Radiosonde_Data_Wexler[:,-1], Radiosonde_Data_Wexler[:,1], label='Wexler', lw=0.5)
		ax1.plot(Radiosonde_Data_Sonntag[:,-1], Radiosonde_Data_Sonntag[:,1], label='Sonntag', lw=0.5)
		
		ax1.set_xlabel('RH $(\%)$')
		ax1.set_title(Title, fontsize=12)
		ax1.legend(loc='best')
		
		ax2 = ax1.twinx()

		ax2.plot(RH, Temperature, label='Original', lw=0.5, c='black')
		
		ax2.set_ylabel('Temperature ($^\circ$C)')
		
		ax2.set_ylim([np.nanmin(Temperature), np.nanmax(Temperature)])
		ax2.invert_yaxis()
		
		Freezing_Height = Height[gu.argnear(Temperature, 0)] if np.any(Temperature < 0) else -1
		print("Freezing_Height", Freezing_Height)
		ax1.axhline(y=Freezing_Height, c='black', ls='-', lw=1)
		
		############################################################################
		"""[Step 3] Save plot and return"""
		
		#Specify the directory the plots are stored in 
		path = os.path.dirname(self.Radiosonde_File).replace(self.Storage_Path + self.Processed_Data_Path,"")
		
		#Find any other plots stored in this directory
		previous_plots = glob.glob(self.Storage_Path + 'Plots/RH_Comparison/' + path + "/*")
		
		#Find the biggest 'v' number in plots
		plot_version = []
		for plots in previous_plots:
			try:
				plot_version.append(int(os.path.basename(plots)[34:37]))
			except ValueError:
				plot_version.append(int(os.path.basename(plots)[34:36]))
		
		plot_version = str(np.max(plot_version)+1) if len(plot_version) != 0 else '1'
		
		#Create full directory and file name
		Save_Location = self.Storage_Path + 'Plots/RH_Comparison/' + path + '/' + path + '_v' + plot_version.rjust(2,'0') + '_' + str(self.height_range[0]).rjust(2,'0') + 'km_to_' + str(self.height_range[1]).rjust(2,'0') + 'km.png'
		
		#Ensure the directory exists on file system and save to that location
		gu.ensure_dir(os.path.dirname(Save_Location))
		plt.savefig(Save_Location, bbox_inches='tight', pad_inches=0.1, dpi=300)
		
		############################################################################
		
		if self.verbose is True: print("[INFO] RH_Comparison completed successfully (In %.2fs)" % (time.time()-t_begin))

	def Ice_Concentration(self, Radiosonde_File=None, Calibrate=None, Height_Range=None, Sensor_Package=None):
		
		gu.cprint("[INFO] You are running Radiosonde_Ice_Concentration from the DEV release", type='bold')
		
		############################################################################
		"""Prerequisites"""
	   
		Storage_Path    		= '/storage/shared/glusterfs/phd/users/th863480/WC3_InSitu_Electrification/'
		Processed_Data_Path		= 'Processed_Data/Radiosonde/'
		Raw_Data_Path			= 'Raw_Data/'
		Plots_Path      		= 'Plots/Radiosonde/'
		
		t_begin = time.time()
		
		############################################################################
		"""[Step 1] Check and Import Data"""
		
		#Error check that either Radiosonde_File or Sensor_Package has been specified
		if Radiosonde_File is None and Sensor_Package is None: sys.exit("[Error] You must specify either the Radiosonde_File location or the Sensor_Package number")
		
		#Attempt to find the radiosonde file either directly or from glob
		Radiosonde_File = Storage_Path + Processed_Data_Path + Radiosonde_File if Radiosonde_File is not None else glob.glob(Storage_Path + Processed_Data_Path + 'Radiosonde_Flight_No.' + str(Sensor_Package).rjust(2,'0') + '_*/Radiosonde_Flight_PhD_James_No.' + str(Sensor_Package) + '*a.txt')
		
		#If no radiosonde file was found we end program
		if len(Radiosonde_File) == 0: sys.exit("[Error] Radiosonde package No.%s does not exist. Has the radiosonde been launched yet or has the data been misplaced?" % (Sensor_Package))
		
		#If the radiosonde file was found via glob we need to convert to str from list
		if isinstance(Radiosonde_File, list): Radiosonde_File = Radiosonde_File[0]
		
		#Import all the data
		if Radiosonde_File is not None: Radiosonde_Data = np.genfromtxt(Radiosonde_File, delimiter=None, skip_header=10, dtype=float, comments="#")
		
		Radiosonde_Cal = Radiosonde_Checks(Radiosonde_Data, Calibrate, Sensor_Package, Height_Range, check=1111)
		Radiosonde_Data = Radiosonde_Cal.return_data()
		
		Time = Radiosonde_Data[:,0][Radiosonde_Data[:,9] == 1112]
		PLL = Radiosonde_Data[:,7][Radiosonde_Data[:,9] == 1112]
		
		PLL[PLL == 0] = np.nan
		print(PLL)
		
		print(np.sum(np.isnan(PLL)))	
		
	def Lightning(self, Data, Radiosonde_File=None, Calibrate=None, Height_Range=None, Sensor_Package=None):
		"""Compares lightning data from ATDnet with the position of a radiosonde"""
		
		from matplotlib.ticker import MultipleLocator, FormatStrFormatter, MaxNLocator, LogLocator, ScalarFormatter
		from matplotlib.colors import LogNorm, ListedColormap
		from matplotlib.dates import DateFormatter, MinuteLocator, HourLocator, DayLocator
		
		gu.cprint("[INFO] You are running Radiosonde_Lightning from the STABLE release", type='bold')
		
		############################################################################
		"""Prerequisites"""
		
		#Time Controls
		t_begin = time.time()
			
		#Storage Locations
		Storage_Path    		= PhD_Global.Storage_Path_WC3
		Processed_Data_Path		= 'Processed_Data/Radiosonde/'
		Raw_Data_Path			= 'Raw_Data/'
		Plots_Path      		= 'Plots/Lightning/'
		
		#Plotting requirements
		plt.style.use('classic') #necessary if Matplotlib version is >= 2.0.0
		
		#Set-up data importer
		EPCC_Data = EPCC_Importer()
		
		#Time Offset
		time_offset = 20.5 #s
		
		############################################################################
		"""[Step 1] Check and Import Data"""
		
		t1 = time.time()
		
		#Error check that either Radiosonde_File or Sensor_Package has been specified
		if Radiosonde_File is None and Sensor_Package is None: sys.exit("[Error] You must specify either the Radiosonde_File location or the Sensor_Package number")
		
		#Attempt to find the radiosonde file either directly or from glob
		Radiosonde_File = Storage_Path + Processed_Data_Path + Radiosonde_File if Radiosonde_File is not None else glob.glob(Storage_Path + Processed_Data_Path + 'Radiosonde_Flight_No.' + str(Sensor_Package).rjust(2,'0') + '_*/Radiosonde_Flight_PhD_James_No.' + str(Sensor_Package) + '*a.txt')
		
		#If no radiosonde file was found we end program
		if len(Radiosonde_File) == 0: sys.exit("[Error] Radiosonde package No.%s does not exist. Has the radiosonde been launched yet or has the data been misplaced?" % (Sensor_Package))
		
		#If the radiosonde file was found via glob we need to convert to str from list
		if isinstance(Radiosonde_File, list): Radiosonde_File = Radiosonde_File[0]
		
		#Once the radiosonde file is found we can attempt to find the GPS file in the raw file section
		GPS_File = glob.glob(Storage_Path + Raw_Data_Path + 'Radiosonde_Flight_No.' + str(Sensor_Package).rjust(2,'0') + '_*/GPSDCC_RESULT*.tsv')
		
		#Import all the data
		if Radiosonde_File is not None: Radiosonde_Data = np.genfromtxt(Radiosonde_File, delimiter=None, skip_header=10, dtype=float, comments="#")
		
		#Get Launch Datetime
		Launch_Datetime, _ = Radiosonde_Launch(GPS_File, offset=time_offset)
		
		#Import ATDnet Data
		ID = np.where(Data['Date_ID'] == gu.toDateOnly(Launch_Datetime))[0][0]
		ATDnet_Time, ATDnet_LatLong = EPCC_Data.ATDnet(Data['ATDnet_File'][ID])
		
		if ATDnet_Time is None: raise IOError("No ATDnet data found for this Radiosonde flight")
		
		############################################################################
		"""[Step 2] Calibrate bespoke sensors"""
		
		t2 = time.time()
		
		#Calibrate Height, Temperature and Convert PANDORA channels from counts to volts if required.
		Radiosonde_Cal_Clean = Radiosonde_Checks(Radiosonde_Data.copy(), Calibrate, Sensor_Package, Height_Range, check=1111, enforce_parity=True)
		Radiosonde_Cal_Error = Radiosonde_Checks(Radiosonde_Data.copy(), Calibrate, Sensor_Package, Height_Range, check=1111, enforce_parity=False)
		
		#Return Data. _Clean : Enforce 1111/1112 parity, _Error: leave other parities alone. Used to identify link with lightning
		Radiosonde_Data_Clean = Radiosonde_Cal_Clean.return_data()
		Radiosonde_Data_Error = Radiosonde_Cal_Error.return_data()
		
		#Non 1111/1112 parity bits converted to nan (except time column)
		Radiosonde_Data_Error[~((Radiosonde_Data_Error[:,9] == 1111) ^ (Radiosonde_Data_Error[:,9] == 1112)),1:] = np.nan
		
		print("Launch_Datetime", Launch_Datetime)
		
		############################################################################
		"""[Step 3] Compare ATDnet with Radiosonde"""
		
		t3 = time.time()
		
		#First, convert Radiosonde time in flight to datetime64
		Radiosonde_Time = np.array(Launch_Datetime, dtype='datetime64[s]') + Radiosonde_Data_Clean[:,0].astype('timedelta64[s]')
		Radiosonde_LatLong = Radiosonde_Data_Clean[:,(11,10)]
		
		t4 = time.time()
		
		#Second, subset ATDnet for times when radiosonde was flying
		ATD_Mask = gu.bool2int((ATDnet_Time >= Radiosonde_Time[0]) & (ATDnet_Time <= Radiosonde_Time[-1]))
		ATDnet_Time = ATDnet_Time[ATD_Mask]
		ATDnet_LatLong = ATDnet_LatLong[ATD_Mask]
		
		#Third, join together the ATDnet timestamps and the Radiosonde timestamps
		mask = gu.mask(Radiosonde_Time, ATDnet_Time, approx=True)
		
		Radiosonde_Time = Radiosonde_Time[mask][0]
		Radiosonde_LatLong = Radiosonde_LatLong[mask][0]

		t5 = time.time()
		
		#Fourth, for each lightning detected, calculate the haversine between the latlong of the lightning and latlong of the radiosonde	
		Lightning_Distance = np.array([gu.haversine(tuple(atdnet_latlong), tuple(radiosonde_latlong))[0] for atdnet_latlong, radiosonde_latlong in zip(ATDnet_LatLong, Radiosonde_LatLong)], dtype=np.float64)

		#Fifth, remove nan values from array (N.B can't use gu.antinan as ATDnet has datetime64 which can't be handled)
		nan_mask = np.isnan(Lightning_Distance)
		ATDnet_Time = ATDnet_Time[~nan_mask]
		Lightning_Distance = Lightning_Distance[~nan_mask]
		
		############################################################################
		"""[Step 4]: Plot time series of lightning strikes"""
		
		Error_Mask = gu.contiguous(np.isnan(Radiosonde_Data_Error[:,5]), invalid=False)
		
		Error_Index = [[gu.bool2int(Error_Mask == val)[0], gu.bool2int(Error_Mask == val)[-1] + 0] for val in np.unique(Error_Mask)[1:]]
		Error_Length = np.diff(Error_Index).ravel()
		Radiosonde_Time_Error = np.array(Launch_Datetime, dtype='datetime64[s]') + Radiosonde_Data_Error[:,0].astype('timedelta64[s]')
			
		#Subset lightning distance to closest 100km strikes
		distance_mask = (Lightning_Distance/1000 < 100)
		ATDnet_Time = ATDnet_Time[distance_mask]
		Lightning_Distance = Lightning_Distance[distance_mask]/1000

		#Clear any previous plots
		gu.backend_changer('nbAgg')
		
		plt.clf()
		plt.close()
		
		#Plot lightning data as time-series
		plt.plot(ATDnet_Time, Lightning_Distance, 'p', ms=3, marker='o', markeredgecolor='None', markerfacecolor='blue', alpha=1, label="Lightning", zorder=4)
		
		plt.ylim([0,100])
		plt.grid(which='major',axis='both',c='grey', zorder=2)
		
		#Configure x axis ticks
		gu.date_ticks(plt.gca(), (ATDnet_Time[0], ATDnet_Time[-1]))
		
		#Write Plot Labels
		plt.ylabel("Distance from Radiosonde (km)")
		plt.title("Distance of Lightning Strikes from Radiosonde Flight No." + str(Sensor_Package))
		
		plt.annotate("$Counts$ = %.0f\n$Closest$ $Strike$ = %.2fkm" % (Lightning_Distance.size, np.nanmin(Lightning_Distance)), xy=(1, 1), xycoords='axes fraction', fontsize=12, xytext=(-5, -5), textcoords='offset points', ha='right', va='top')
		
		#Add fill_between highlighting when communication was lost with the Radiosonde
		cmap = plt.cm.Set2
		norm = plt.matplotlib.colors.Normalize(vmin=1, vmax=9)
		for i, (Error, Length) in enumerate(zip(Error_Index, Error_Length)): 
			plt.axvspan(Radiosonde_Time_Error[Error[0]], Radiosonde_Time_Error[Error[1]], alpha=0.5, color=cmap(norm(Length)), zorder=3)
			
		plt.tight_layout()
		
		#Create colour bar for the communication black-out time
		sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
		sm.set_array([])
		cb = plt.colorbar(sm, orientation='vertical', pad=0.01, ticks=[1,2,3,4,5,6,7,8,9])
		cb.set_label('Comms. Blackout ($s$)', labelpad=1, fontsize=10)
		cb.ax.set_xticklabels(['1', '2', '3', '4', '5', '6', '7', '8','9'])
		cb.ax.tick_params(labelsize=10)
		
		##SAVE PLOT###
		
		#Specify the directory the plots are stored in 
		path = os.path.dirname(Radiosonde_File).replace(Storage_Path + Processed_Data_Path,"")
		
		#Find any other plots stored in this directory
		previous_plots = glob.glob(Storage_Path + Plots_Path + path + "Timeseries/*")
		
		#Find the biggest 'v' number in plots
		plot_version = []
		for plots in previous_plots:
			try:
				plot_version.append(int(os.path.basename(plots)[34:37]))
			except ValueError:
				plot_version.append(int(os.path.basename(plots)[34:36]))
		
		plot_version = str(np.max(plot_version)+1) if len(plot_version) != 0 else '1'
		
		#Create full directory and file name
		Save_Location = Storage_Path + Plots_Path + path + '/Timeseries/' + path + '_v' + plot_version.rjust(2,'0') + '_LightningTimeseries.png'
		
		#Ensure the directory exists on file system and save to that location
		gu.ensure_dir(os.path.dirname(Save_Location))
		plt.savefig(Save_Location, bbox_inches='tight', pad_inches=0.1, dpi=300)
		
		print("Time series", Save_Location)
		
		############################################################################
		"""[Step 5] Plot lightning strikes and position of radiosonde on a map
		
		
		OPTIONS: USE THE fNorth AND fEast VALUES IN GPSDCC_RESULT TO CALCULATE THE 
		RADIOSONDE POSITION MORE ACCURATELY!"""
		
		from mpl_toolkits.basemap import Basemap
		
		from mpl_toolkits.axes_grid1.inset_locator import zoomed_inset_axes
		from mpl_toolkits.axes_grid1.inset_locator import inset_axes
		from matplotlib.patches import Polygon
		from matplotlib.dates import date2num, num2date
		from matplotlib.collections import LineCollection
		
		gu.backend_changer()
		
		#Provide dimensions of map
		lonW_Small = -2.0
		lonE_Small = 1.0
		latN_Small = 52.5
		latS_Small = 50.5

		lonW_Large = -11.0
		lonE_Large = 2.5
		latN_Large = 61.0
		latS_Large = 49.0
		
		#Map positioning
		Position = {'upper right' : (lonE_Small-0.55, latN_Small-0.15), 'upper left' : (lonW_Small+0.2, latN_Small-0.15),
			'lower right' : (lonE_Small-0.55, latS_Small+0.15), 'lower left' : (lonW_Small+0.2, latS_Small+0.15)}
		
		#Map Resolution
		map_res = 'f'
		
		#Create base map
		fig = plt.figure()
		ax = fig.add_subplot(111)

		map = Basemap(projection='merc',
			lat_0=51,
			lon_0=-3,
			resolution=map_res,
			llcrnrlon=lonW_Small,
			llcrnrlat=latS_Small,
			urcrnrlon=lonE_Small,
			urcrnrlat=latN_Small,
			ax=ax)
		
		#Define centre of map
		LatLong_Centre = [0.5*(latN_Small + latS_Small), 0.5*(lonE_Small + lonW_Small)]
		
		#Add overlays to map
		map.drawmapboundary(fill_color='LightBlue', zorder=0)
		map.fillcontinents(color='white', lake_color='LightBlue', zorder=0)
		map.drawcoastlines(color='DimGrey', linewidth=1, zorder=0)
		map.drawcountries(color='Grey', linewidth=1, zorder=0)
		map.drawmeridians(np.arange(-15, 5, 1),linewidth=0.5,color='DarkGrey',labels=[0,0,0,1], zorder=0)
		map.drawparallels(np.arange(-50, 70, 1),linewidth=0.5,color='DarkGrey',labels=[1,0,0,0], zorder=0)
		plt.title('Location of Lightning Strikes and Radiosonde Trajectory (Flight No.5)')

		city_labels = True
		if city_labels is True:
			
			# lat/lon coordinates to plot
			lats = [51.441314]
			lons = [-0.937447]
			
			# compute the native map projection coordinates
			x,y = map(lons,lats)
			
			map.scatter(x,y,s=30, edgecolors='DimGrey', marker='s', facecolors='none', alpha=1, zorder=5)
			
			label_txt = ['RUAO']
			
			for lab in range(0,np.size(x)): 
				plt.text(x[lab], y[lab], label_txt[lab], color='black', size=10,
					horizontalalignment='center', verticalalignment='top', zorder=6)
		
		#Create colour bar for plotting time progression
		Radiosonde_Time = date2num(Radiosonde_Time.astype(datetime))
		ATDnet_Time = date2num(ATDnet_Time.astype(datetime))
		
		#Configure colour-map setting
		cmap = plt.cm.rainbow
		norm = plt.matplotlib.colors.Normalize(vmin=Radiosonde_Time[0], vmax=Radiosonde_Time[-1])
		scalarMap = plt.cm.ScalarMappable(norm=norm, cmap='rainbow')	
		scalarMap.set_array([])
		
		print("Radiosonde_Time", Radiosonde_Time.dtype, Radiosonde_Time.shape, Radiosonde_Time.size)
		print("ATDnet_Time", ATDnet_Time.dtype, ATDnet_Time.shape, ATDnet_Time.size)
		
		#Add ATDnet Lightning Strikes
		x, y = map(ATDnet_LatLong[:,1], ATDnet_LatLong[:,0])
		map.scatter(x, y, s=5, marker='o', edgecolors='None', alpha=1, facecolor=cmap(norm(ATDnet_Time)))

		#Add Radiosonde Trajectory
		x, y = map(Radiosonde_LatLong[:,1], Radiosonde_LatLong[:,0])
		xy = np.vstack((x,y)).T
		for rad_time, start, stop in zip(Radiosonde_Time, xy[:-1], xy[1:]):
			xval, yval = zip(start, stop)
			map.plot(xval, yval, '-', lw=1, color=cmap(norm(rad_time)))
			
		#Add scale bar
		map.drawmapscale(*Position['lower right'],
			lat0=LatLong_Centre[0], lon0=LatLong_Centre[1], length=100, units='km', barstyle='fancy', ax=ax)
		
		#Create inset map axes
		axin = inset_axes(map.ax, width="30%", height="30%", loc=3)

		#Create inset map on the same Mercator Geographic Coordinate System
		omap = Basemap(projection='merc',
			lat_0=51,
			lon_0=-3,
			resolution=map_res,
			llcrnrlon=lonW_Large,
			llcrnrlat=latS_Large,
			urcrnrlon=lonE_Large,
			urcrnrlat=latN_Large,
			ax=axin)
			
		#Add overlays to map
		omap.drawmapboundary(fill_color='LightBlue')
		omap.fillcontinents(color='white',lake_color='LightBlue')
		omap.drawcoastlines(color='DimGrey', linewidth=.5)
		omap.drawcountries(color='Grey', linewidth=.5)
		
		#Add Zoomed Box
		bx, by = omap(map.boundarylons, map.boundarylats)
		xy = list(zip(bx,by))
		mapboundary = Polygon(xy,edgecolor='red',linewidth=2,fill=False)
		omap.ax.add_patch(mapboundary)
		
		#Create colour bar for the communication black-out time
		sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
		sm.set_array([])
		myFmt = plt.matplotlib.dates.DateFormatter('%H:%M')
		cb = plt.colorbar(sm, orientation='vertical', pad=0.01, label="Time (UTC)", format=myFmt, fraction=0.04)
		cb.ax.tick_params(labelsize=10)
		
		##SAVE PLOT###
		
		#Specify the directory the plots are stored in 
		path = os.path.dirname(Radiosonde_File).replace(Storage_Path + Processed_Data_Path,"")
		
		#Find any other plots stored in this directory
		previous_plots = glob.glob(Storage_Path + Plots_Path + path + "/Map/*")
		
		print("LOOKING", Storage_Path + Plots_Path + path + "/Map/")
		print("previous_plots", previous_plots)
		
		#Find the biggest 'v' number in plots
		plot_version = []
		for plots in previous_plots:
			try:
				plot_version.append(int(os.path.basename(plots)[34:37]))
			except ValueError:
				plot_version.append(int(os.path.basename(plots)[34:36]))
		
		plot_version = str(np.max(plot_version)+1) if len(plot_version) != 0 else '1'
		
		#Create full directory and file name
		Save_Location = Storage_Path + Plots_Path + path + '/Map/' + path + '_v' + plot_version.rjust(2,'0') + '_LightningMap.png'
		
		#Ensure the directory exists on file system and save to that location
		gu.ensure_dir(os.path.dirname(Save_Location))
		plt.savefig(Save_Location, bbox_inches='tight', pad_inches=0.1, dpi=300)
		
		print("Map", Save_Location)
		
		t6 = time.time()
		
		print("Time t2-t1 = %.2fs, t3-t2 = %.2fs, t4-t3 = %.2fs, t5-t4 = %.2fs, t6-t5 = %.2fs, Total = %.2fs" % 
			(t2-t1, t3-t2, t4-t3, t5-t4, t6-t5, t6-t1))
		
		print("[INFO] Radiosonde_Lightning completed successfully (In %.2fs)" % (time.time()-t_begin))	
		
		sys.exit()
		
if __name__ == "__main__":
	"""Launch the Radiosonde_Analysis.py from the command line. This python script gives command line
	options which can be found using Radiosonde_Analysis.py --help. An example input for a radiosonde
	flight is given as,
	
	>>> python Radiosonde_Analysis.py --sensor 3 --height 0.0 2.0 --calibrate count
	
	if using Radiosonde_ChargeCalibrator use:
	
	>>> python Radiosonde_Analysis.py --sensor x --height zmin zmax --calibrate volts
	
	where x is the radiosonde flight number, zmin and zmax are the height boundaries where you want to 
	perform the calibration and volts or units is required for calibrate to correctly get the linear
	current. Notes for zmin and zmax are to use an area of the ascent where both linear and log charge
	sensors did not saturate. Otherwise, the calibration will have a systematic bias.
	
	"""
	
	gu.cprint("Welcome to Radiosonde Analysis. Plotting the sounding data and calculating profile indices.", type='bold')
		
	############################################################################
	"""Process Command Line Arguments"""
	
	parser = argparse.ArgumentParser(description='Plot the radiosonde data for each flight during my PhD. The calibration from counts to voltage to quantity is applied automatically if found in Radiosonde_Calibration.py')
	
	#Command Line Arguments
	parser.add_argument('-v','--height',
		action="store", dest="height_range", nargs='+', type=float,
		help="Specify the minimum height used for plotting the radiosonde data. The format should be '-h 0 18' where 0 and 18 are the lower and upper bound heights respectively.", 
		default=(0,18), required=True)
	
	parser.add_argument('-s','--sensor',
		action="store", dest="sensor_package", type=int,
		help="Specify the radiosonde sensor package you want to plot. Ranges from 1+",
		default=1, required=True)

	parser.add_argument('-c', '--calibrate',
		action="store", dest="calibrate", type=str,
		help="Specify what level of calibration you want to apply to the research channels. Select either 'counts', 'volts', 'units' are available options",
		default='units', required=False)
	
	parser.add_argument('--tephigram',
		action='store_true', dest="plot_tephigram",
		help="Specify if you want to plot the tephigram of the specify radiosonde flight")
		
	parser.add_argument('--camborne',
		action='store_true', dest="plot_camborne",
		help="Specify if you want to plot the Camborne Upper Level Sounding data on top of the radiosonde data")
	
	parser.add_argument('--reload',
		action='store_true', dest="reload",
		help="Specify if you want to reload the data processing of the chosen radiosonde flight.")
		
	parser.add_argument('--verbose',
		action='store_true', dest="verbose",
		help="Specify if you want output extra information about the data processing.")
		
	arg = parser.parse_args()
	arg.plot_tephigram = bool(arg.plot_tephigram)
	arg.plot_camborne = bool(arg.plot_camborne)
	
	if not np.any(np.in1d(arg.calibrate, ['volts', 'units', 'counts'])): sys.exit("[Error] Radiosonde_Analysis requires the Calibrate argument to be specified with either 'counts', 'volts' or 'units")
	
	#Convert Calibrate and Height_Range into tuples
	arg.height_range = tuple(arg.height_range)
	arg.calibrate = arg.calibrate.capitalize()

	#Initialise Clouds_ID, LayerType
	Clouds_ID = None
	LayerType = None
	
	############################################################################
	"""Start of Main Function"""
	
	tstart_main = time.time()
	
	gu.cprint("Everything was set-up correctly. Let crunch some numbers!", type='okblue')
	
	Data = PhD_Global.Data_CHIL

	
	Rad = Radiosonde(sensor_package=arg.sensor_package, height_range=arg.height_range, calibrate=arg.calibrate, reload=arg.reload, verbose=arg.verbose)
	#Rad.Superplotter()
	Rad.ChargeOpticalCorrelation()
	
	print("FINISHED")
	sys.exit()
	
	
	
	
	
	Rad.Tephigram(plot_tephigram=arg.plot_tephigram, plot_camborne=arg.plot_camborne)
	
	
	
	Rad.RH_Comparison()
	sys.exit()
	
	#Identify the clouds within the radiosonde data
	Clouds_ID, LayerType = Radiosonde_CloudIdentifier(Height_Range=arg.Height_Range, Sensor_Package=arg.Sensor_Package)
	
	#Determine the charge calibration for the log sensor
	if np.any(np.in1d(arg.Calibrate, ['volts', 'units'])):
		Calibration_Log = Radiosonde_ChargeCalibrator(Calibrate=arg.Calibrate, Sensor_Package=arg.Sensor_Package)
	
	#Plot Radiosonde Data together in Cartesian Coordinates
	if np.any(np.in1d(arg.Calibrate, ['volts', 'units'])):
		Radiosonde_Superplotter(Calibrate=arg.Calibrate, Height_Range=arg.Height_Range, Sensor_Package=arg.Sensor_Package, Clouds_ID=Clouds_ID, LayerType=LayerType, Calibration_Log=Calibration_Log)
	else:
		Radiosonde_Superplotter(Calibrate=arg.Calibrate, Height_Range=arg.Height_Range, Sensor_Package=arg.Sensor_Package, Clouds_ID=Clouds_ID, LayerType=LayerType)
	sys.exit()
	
	
	#Plot Radiosonde Data together in Tephigram Coordinates
	Radiosonde_Tephigram(Height_Range=arg.Height_Range, Sensor_Package=arg.Sensor_Package, plot_tephigram=arg.plot_tephigram, plot_camborne=arg.plot_camborne)
	
	#Plot Lightning maps and comparison with Radiosonde Trajectory
	Radiosonde_Lightning(Data, Calibrate=arg.Calibrate, Height_Range=arg.Height_Range, Sensor_Package=arg.Sensor_Package)
	
	#IN THE FUTURE:
	#Radiosonde_ChargeCalibrator(Calibrate=arg.Calibrate, Height_Range=arg.Height_Range, Sensor_Package=arg.Sensor_Package)
	#Radiosonde_Ice_Concentration(Calibrate=arg.Calibrate, Height_Range=arg.Height_Range, Sensor_Package=arg.Sensor_Package)
	
	gu.cprint("[Radiosonde_Analysis]: All Tasks Completed, Time Taken (s): %.0f" % (time.time()-tstart_main), type='okgreen')